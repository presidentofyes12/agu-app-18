=== ./index.tsx ===
import React from 'react';
import { Box, Typography, Button } from '@mui/material';
import { Channel, Message } from 'types';

interface DashboardProps {
  channel: Channel;
  messages: Message[];
}

const Dashboard: React.FC<DashboardProps> = ({ channel, messages }) => {
  return (
    <Box sx={{ p: 2 }}>
      <Typography variant="h4">Dashboard</Typography>
      
      {/* Committees */}
      <Box sx={{ mb: 4 }}>
        <Typography variant="h5">Committees</Typography>
        {/* Add committee information here */}
      </Box>

      {/* Proposal Details */}
      <Box sx={{ mb: 4 }}>
        <Typography variant="h5">Proposal Details</Typography>
        <Typography>Name: {channel.name}</Typography>
        <Typography>Creator: {channel.creator}</Typography>
        {/* Add more proposal details here */}
      </Box>

      {/* Activities */}
      <Box sx={{ mb: 4 }}>
        <Typography variant="h5">Activities</Typography>
        {messages.slice(0, 5).map((message) => (
          <Box key={message.id} sx={{ mb: 1 }}>
            <Typography>Contributor: {message.creator}</Typography>
            <Typography>Message: {message.content}</Typography>
          </Box>
        ))}
      </Box>

      {/* Rewards */}
      <Box>
        <Typography variant="h5">Rewards</Typography>
        <Typography>Reward distribution to be implemented</Typography>
      </Box>
    </Box>
  );
};

export default Dashboard;=== ./TokenMetrics.tsx ===
import React, { useEffect, useState } from 'react';
import { ContractService } from './contractService';
import { ethers } from 'ethers';
import { 
  Card,
  CardHeader,
  CardContent,
  Typography,
  Alert,
  AlertTitle,
  CircularProgress,
  Box 
} from '@mui/material';

import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer
} from 'recharts';

const TokenMetrics = () => {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [metrics, setMetrics] = useState({
    price: 0,
    supply: '0',
    marketCap: '0',
    volume24h: '0',
    priceChange24h: 0,
    totalStaked: '0',
    treasuryBalance: '0',
    priceHistory: []
  });

  useEffect(() => {
    const fetchMetrics = async () => {
      try {
        setLoading(true);
        
        // Initialize provider and contract service
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const contractService = new ContractService(
          provider,
          '0x23767A0C9A072C6A081C27A1C03Cc95B9F9cc6E0' // Your contract address
        );

        // Fetch metrics from contract
        const contractMetrics = await contractService.getTokenMetrics();

        // Calculate market cap
        const marketCap = (
          parseFloat(contractMetrics.price) * 
          parseFloat(contractMetrics.supply)
        ).toFixed(2);

        setMetrics(prev => ({
          ...prev,
          price: parseFloat(contractMetrics.price),
          supply: contractMetrics.supply,
          marketCap,
          treasuryBalance: contractMetrics.treasuryBalance,
          priceHistory: [
            ...prev.priceHistory,
            {
              timestamp: Date.now(),
              price: parseFloat(contractMetrics.price)
            }
          ].slice(-24)
        }));

        setLoading(false);
      } catch (error) {
        console.error('Error fetching token metrics:', error);
        setError('Failed to fetch token metrics');
        setLoading(false);
      }
    };

    fetchMetrics();
    const interval = setInterval(fetchMetrics, 60000);
    return () => clearInterval(interval);
  }, []);

  const formatUSD = (value) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(Number(value));
  };

  const formatPercent = (value) => {
    return new Intl.NumberFormat('en-US', {
      style: 'percent',
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
      signDisplay: 'exceptZero'
    }).format(value / 100);
  };

  if (loading) {
    return (
      <Card>
        <CardHeader>
          <Typography variant="h6">Token Metrics</Typography>
        </CardHeader>
        <CardContent>
          <Box display="flex" justifyContent="center" alignItems="center" minHeight={200}>
            <CircularProgress />
          </Box>
        </CardContent>
      </Card>
    );
  }

  if (error) {
    return (
      <Card>
        <CardHeader>
          <Typography variant="h6">Token Metrics</Typography>
        </CardHeader>
        <CardContent>
          <Alert severity="error">
            <AlertTitle>Error</AlertTitle>
            {error}
          </Alert>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <Typography variant="h6">Token Metrics</Typography>
      </CardHeader>
      <CardContent>
        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
          {/* Price and Change Section */}
          <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'baseline' }}>
              <Typography variant="h4" component="div">
                {formatUSD(metrics.price)}
              </Typography>
              <Typography 
                variant="body2" 
                sx={{ 
                  color: metrics.priceChange24h >= 0 ? 'success.main' : 'error.main',
                  fontWeight: 'medium'
                }}
              >
                {formatPercent(metrics.priceChange24h)}
              </Typography>
            </Box>
            
            <Box sx={{ height: '120px', width: '100%' }}>
              <ResponsiveContainer width="100%" height="100%">
                <LineChart data={metrics.priceHistory}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis 
                    dataKey="timestamp"
                    tickFormatter={(timestamp) => {
                      return new Date(timestamp).toLocaleTimeString('en-US', {
                        hour: '2-digit',
                        minute: '2-digit'
                      });
                    }}
                  />
                  <YAxis 
                    domain={['auto', 'auto']}
                    tickFormatter={(value) => formatUSD(value)}
                  />
                  <Tooltip
                    formatter={(value) => [formatUSD(value), 'Price']}
                    labelFormatter={(label) => new Date(label).toLocaleString()}
                  />
                  <Line 
                    type="monotone"
                    dataKey="price"
                    stroke="#8884d8"
                    strokeWidth={2}
                    dot={false}
                  />
                </LineChart>
              </ResponsiveContainer>
            </Box>
          </Box>

          {/* Key Metrics Grid */}
          <Box sx={{ 
            display: 'grid', 
            gridTemplateColumns: 'repeat(2, 1fr)', 
            gap: 2 
          }}>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 0.5 }}>
              <Typography variant="body2" color="text.secondary">Market Cap</Typography>
              <Typography variant="body1" fontWeight="medium">
                {formatUSD(metrics.marketCap)}
              </Typography>
            </Box>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 0.5 }}>
              <Typography variant="body2" color="text.secondary">24h Volume</Typography>
              <Typography variant="body1" fontWeight="medium">
                {formatUSD(metrics.volume24h)}
              </Typography>
            </Box>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 0.5 }}>
              <Typography variant="body2" color="text.secondary">Total Supply</Typography>
              <Typography variant="body1" fontWeight="medium">
                {Number(metrics.supply).toLocaleString()} PITA
              </Typography>
            </Box>
          </Box>

          {/* Treasury Balance */}
          <Box sx={{ 
            pt: 2, 
            borderTop: 1, 
            borderColor: 'divider',
            display: 'flex',
            flexDirection: 'column',
            gap: 0.5
          }}>
            <Typography variant="body2" color="text.secondary">
              Treasury Balance
            </Typography>
            <Typography variant="h5" fontWeight="bold">
              {formatUSD(parseFloat(metrics.treasuryBalance) * metrics.price)}
            </Typography>
            <Typography variant="body2" color="text.secondary">
              {Number(metrics.treasuryBalance).toLocaleString()} PITA
            </Typography>
          </Box>

          {/* Additional Stats */}
          <Box sx={{ 
            pt: 2, 
            borderTop: 1, 
            borderColor: 'divider',
            display: 'grid',
            gridTemplateColumns: 'repeat(2, 1fr)',
            gap: 2
          }}>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 0.5 }}>
              <Typography variant="body2" color="text.secondary">
                Daily Allocation
              </Typography>
              <Typography variant="body1" fontWeight="medium">
                {formatUSD(metrics.dailyAllocation)}
              </Typography>
            </Box>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 0.5 }}>
              <Typography variant="body2" color="text.secondary">
                Supply Growth
              </Typography>
              <Typography variant="body1" fontWeight="medium">
                {formatPercent(2.1)}
              </Typography>
            </Box>
          </Box>

          {/* Market Status Indicator */}
          <Box sx={{ 
            pt: 2, 
            borderTop: 1, 
            borderColor: 'divider',
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center'
          }}>
            <Typography variant="body2" color="text.secondary">
              Market Status
            </Typography>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
              <Box sx={{ 
                width: 8, 
                height: 8, 
                borderRadius: '50%',
                bgcolor: metrics.priceChange24h >= 0 ? 'success.main' : 'error.main'
              }} />
              <Typography variant="body2" fontWeight="medium">
                {metrics.priceChange24h >= 0 ? 'Bullish' : 'Bearish'}
              </Typography>
            </Box>
          </Box>
        </Box>
      </CardContent>
    </Card>
  );
};

export default TokenMetrics;
=== ./contractService.js ===
// contractService.js
import { ethers } from 'ethers';

// The minimum ABI needed for interactions
const tokenAbi = [
    // Add DAO status functions
    "function proposalCount() external view returns (uint256)",
    "function activeUserCount() external view returns (uint256)",
    "function currentEpoch() external view returns (uint256)",
    "function lastEpochUpdate() external view returns (uint256)",
    "function currentStage() external view returns (uint256)",
    "function daoAnalytics() external view returns (uint256, uint256, uint256, uint256)",
    // Add proposal creation functions to ABI
    "function createProposal(address proposer, uint8 category, uint256 startEpoch, uint256 endEpoch) external returns (uint256)",
    "function proposalCount() external view returns (uint256)",
    "function currentEpoch() external view returns (uint256)",
    // Add voting-related functions to ABI
    "function getProposalState(uint256 proposalId) external view returns (uint8, uint256, uint256, bool, bool, uint256, uint256, uint8, uint256)",
    "function castVote(uint256 proposalId, bool support, uint256 voteAmount) external",
    "function getProposalBasicInfo(uint256 proposalId) external view returns (uint256, uint256, bool, bool, uint256, uint256, uint8, uint256)",
    "function initializeAdmin() external",
    "function registerMember(address member) external",
    "function isDaoMember(address) external view returns (bool)",
    "function activeDaoList(uint256) external view returns (address)",
    "function daoPosInList(address) external view returns (uint256)",
    "function performAnnualMint() external",
    "function isActiveUser(address) external view returns (bool)",
    "function daoBiddingShares(address) external view returns (uint256)",
    "function activeUserCount() external view returns (uint256)",
    "function lastAnnualMint() external view returns (uint256)",
    "function totalSupply() external view returns (uint256)",
    "function placeBid(uint256 amount, uint256 price, bool isPermanent) external",
    "function getDaoLimit(address) external view returns (uint256)",
    "function getTotalDaoBids(address) external view returns (uint256)",
    "function dailyAllocation() external view returns (uint256)",
    "function calculateDailyAllocation() external",
    "function recordActivity(address) external",
    "function lastActivity(address) external view returns (uint256)",
    "function currentDailyPrice() external view returns (uint256)",
    "function treasuryBalance() external view returns (uint256)",
    "function balanceOf(address) external view returns (uint256)"
];

export class ContractService {
    constructor(provider, contractAddress) {
        this.provider = provider;
        this.contractAddress = contractAddress;
        this.contract = new ethers.Contract(contractAddress, tokenAbi, provider.getSigner());
    }

    // Add DAO status methods
    async getDAOStatus() {
        try {
            const [
                proposalCount,
                activeUserCount,
                currentEpoch,
                lastEpochUpdate,
                currentStage,
                analytics
            ] = await Promise.all([
                this.contract.proposalCount(),
                this.contract.activeUserCount(),
                this.contract.currentEpoch(),
                this.contract.lastEpochUpdate(),
                this.contract.currentStage(),
                this.contract.daoAnalytics()
            ]);

            return {
                proposalCount: proposalCount.toNumber(),
                activeUserCount: activeUserCount.toNumber(),
                currentEpoch: currentEpoch.toNumber(),
                lastEpochUpdate: lastEpochUpdate.toNumber(),
                currentStage: currentStage.toNumber(),
                analytics: {
                    transactions: analytics[0].toNumber(),
                    users: analytics[1].toNumber(),
                    votes: analytics[2].toNumber(),
                    velocity: analytics[3].toNumber()
                }
            };
        } catch (error) {
            console.error('Error getting DAO status:', error);
            throw error;
        }
    }
}

    // Add proposal creation methods
    async createProposal(category, votingPeriodInDays) {
        try {
            const currentEpoch = await this.contract.currentEpoch();
            const startEpoch = currentEpoch.add(1); // Start next epoch
            const endEpoch = currentEpoch.add(votingPeriodInDays * 24); // Convert days to epochs
            
            const signer = this.provider.getSigner();
            const address = await signer.getAddress();
            
            const tx = await this.contract.createProposal(
                address,
                category,
                startEpoch,
                endEpoch
            );
            
            const receipt = await this.logTransaction(tx, 'Create Proposal');
            
            // Get the proposal ID from the event logs
            const proposalCreatedEvent = receipt.events.find(
                event => event.event === 'ProposalCreated'
            );
            
            return proposalCreatedEvent.args.proposalId;
        } catch (error) {
            console.error('Error creating proposal:', error);
            throw error;
        }
    }

    async getCurrentEpoch() {
        try {
            const epoch = await this.contract.currentEpoch();
            return epoch.toNumber();
        } catch (error) {
            console.error('Error getting current epoch:', error);
            throw error;
        }
    }

    async getProposalCount() {
        try {
            const count = await this.contract.proposalCount();
            return count.toNumber();
        } catch (error) {
            console.error('Error getting proposal count:', error);
            throw error;
        }
    }
}

    // Helper function to format addresses for logging
    formatAddress(address) {
        return `${address.substring(0, 6)}...${address.substring(38)}`;
    }

    // Helper function to log transaction details
    async logTransaction(tx, description) {
        console.log(`\n📝 Transaction Details (${description}):`);
        console.log(`- Hash: ${tx.hash}`);
        console.log(`- From: ${this.formatAddress(tx.from)}`);
        console.log(`- To: ${this.formatAddress(tx.to)}`);
        console.log(`- Nonce: ${tx.nonce}`);
        console.log('- Data:', tx.data);
        
        const receipt = await tx.wait();
        console.log('\n✅ Transaction Confirmed:');
        console.log(`- Block: ${receipt.blockNumber}`);
        console.log(`- Gas Used: ${receipt.gasUsed.toString()}`);
        return receipt;
    }

    // Token Metrics Functions
    async getTokenMetrics() {
        try {
            const [
                currentPrice,
                totalSupply,
                treasuryBalance,
                activeUserCount,
                dailyAllocation
            ] = await Promise.all([
                this.contract.currentDailyPrice(),
                this.contract.totalSupply(),
                this.contract.treasuryBalance(),
                this.contract.activeUserCount(),
                this.contract.dailyAllocation()
            ]);

            return {
                price: ethers.utils.formatEther(currentPrice),
                supply: ethers.utils.formatEther(totalSupply),
                treasuryBalance: ethers.utils.formatEther(treasuryBalance),
                activeUsers: activeUserCount.toNumber(),
                dailyAllocation: ethers.utils.formatEther(dailyAllocation)
            };
        } catch (error) {
            console.error('Error fetching token metrics:', error);
            throw error;
        }
    }

    // Membership Functions
    async getMembershipStatus(address) {
        try {
            const [
                isActive,
                biddingShares,
                lastActivityTime
            ] = await Promise.all([
                this.contract.isActiveUser(address),
                this.contract.daoBiddingShares(address),
                this.contract.lastActivity(address)
            ]);

            return {
                isActive,
                biddingShares: biddingShares.toNumber(),
                lastActivity: lastActivityTime.toNumber()
            };
        } catch (error) {
            console.error('Error fetching membership status:', error);
            throw error;
        }
    }

    // Bidding Functions
    async placeBid(amount, price, isPermanent) {
        try {
            const tx = await this.contract.placeBid(amount, price, isPermanent);
            return this.logTransaction(tx, 'Place Bid');
        } catch (error) {
            console.error('Error placing bid:', error);
            throw error;
        }
    }

    // Calculate bid constraints for a DAO
    async getBidConstraints(daoAddress) {
        try {
            const [
                dailyAllocation,
                daoLimit,
                totalBids
            ] = await Promise.all([
                this.contract.dailyAllocation(),
                this.contract.getDaoLimit(daoAddress),
                this.contract.getTotalDaoBids(daoAddress)
            ]);

            const minBidAmount = dailyAllocation.div(1000); // 0.1% minimum
            const maxPermanentBidAmount = daoLimit.mul(25).div(100); // 25% limit
            const availableBidRoom = daoLimit.sub(totalBids);

            return {
                minBidAmount,
                maxPermanentBidAmount,
                availableBidRoom,
                daoLimit,
                totalBids
            };
        } catch (error) {
            console.error('Error calculating bid constraints:', error);
            throw error;
        }
    }

    // Activity Recording
    async recordActivity(address) {
        try {
            const tx = await this.contract.recordActivity(address);
            return this.logTransaction(tx, 'Record Activity');
        } catch (error) {
            console.error('Error recording activity:', error);
            throw error;
        }
    }

    // Daily Allocation
    async calculateDailyAllocation() {
        try {
            const tx = await this.contract.calculateDailyAllocation();
            return this.logTransaction(tx, 'Calculate Daily Allocation');
        } catch (error) {
            console.error('Error calculating daily allocation:', error);
            throw error;
        }
    }

    // Initialization
    async initializeAdmin() {
        try {
            const tx = await this.contract.initializeAdmin();
            return this.logTransaction(tx, 'Initialize Admin');
        } catch (error) {
            console.error('Error initializing admin:', error);
            throw error;
        }
    }

    // Member Registration
    async registerMember(memberAddress) {
        try {
            const tx = await this.contract.registerMember(memberAddress);
            return this.logTransaction(tx, 'Register Member');
        } catch (error) {
            console.error('Error registering member:', error);
            throw error;
        }
    }

    // Add voting-related methods
    async getProposalState(proposalId) {
        try {
            const [
                state,
                startEpoch,
                endEpoch,
                canceled,
                executed,
                forVotes,
                againstVotes,
                stage,
                proposerReputation
            ] = await this.contract.getProposalState(proposalId);

            return {
                state,
                startEpoch: startEpoch.toNumber(),
                endEpoch: endEpoch.toNumber(),
                canceled,
                executed,
                forVotes,
                againstVotes,
                stage,
                proposerReputation
            };
        } catch (error) {
            console.error('Error getting proposal state:', error);
            throw error;
        }
    }

    async castVote(proposalId, support, voteAmount) {
        try {
            const tx = await this.contract.castVote(proposalId, support, voteAmount);
            return this.logTransaction(tx, 'Cast Vote');
        } catch (error) {
            console.error('Error casting vote:', error);
            throw error;
        }
    }

    async getProposalBasicInfo(proposalId) {
        try {
            const info = await this.contract.getProposalBasicInfo(proposalId);
            return {
                startEpoch: info[0].toNumber(),
                endEpoch: info[1].toNumber(),
                canceled: info[2],
                executed: info[3],
                forVotes: info[4],
                againstVotes: info[5],
                stage: info[6],
                proposerReputation: info[7]
            };
        } catch (error) {
            console.error('Error getting proposal info:', error);
            throw error;
        }
    }
}
=== ./VotingInterface.tsx ===
import React, { useState, useEffect } from 'react';
import { ContractService } from './contractService';
import { ethers } from 'ethers';

import {
  Card,
  CardContent,
  CardHeader,
  Typography,
  Button,
  LinearProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  Box,
  TextField
} from '@mui/material';

import { Loader2, ThumbsUp, ThumbsDown, Timer, Users } from 'lucide-react';

const ProposalState = {
  Pending: 0,
  Active: 1,
  Canceled: 2,
  Defeated: 3,
  Succeeded: 4,
  Executed: 5
};

const VotingInterface = ({ proposal }) => {
  const [loading, setLoading] = useState(false);
  const [proposalState, setProposalState] = useState(null);
  const [timeRemaining, setTimeRemaining] = useState('');
  const [voteAmount, setVoteAmount] = useState('');
  const [voteForDialogOpen, setVoteForDialogOpen] = useState(false);
  const [voteAgainstDialogOpen, setVoteAgainstDialogOpen] = useState(false);
  const [contractService, setContractService] = useState(null);

  // Initialize contract service
  useEffect(() => {
    const initializeContract = async () => {
      try {
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const service = new ContractService(
          provider,
          '0x23767A0C9A072C6A081C27A1C03Cc95B9F9cc6E0' // Contract address
        );
        setContractService(service);
        
        // Fetch initial proposal state
        if (proposal.id) {
          const state = await service.getProposalState(proposal.id);
          setProposalState(state);
        }
      } catch (error) {
        console.error('Error initializing contract:', error);
      }
    };

    initializeContract();
  }, [proposal.id]);

  // Update time remaining
  useEffect(() => {
    const updateTimeRemaining = () => {
      if (!proposalState) return;

      const now = Math.floor(Date.now() / 1000);
      const end = proposalState.endEpoch;
      const diff = end - now;

      if (diff <= 0) {
        setTimeRemaining('Voting ended');
        return;
      }

      const days = Math.floor(diff / (24 * 60 * 60));
      const hours = Math.floor((diff % (24 * 60 * 60)) / (60 * 60));
      const minutes = Math.floor((diff % (60 * 60)) / 60);

      setTimeRemaining(`${days}d ${hours}h ${minutes}m remaining`);
    };

    updateTimeRemaining();
    const interval = setInterval(updateTimeRemaining, 60000);
    return () => clearInterval(interval);
  }, [proposalState]);

  // Handle voting
  const handleVote = async (support) => {
    if (!contractService || !voteAmount) return;

    setLoading(true);
    try {
      const amount = ethers.utils.parseEther(voteAmount);
      await contractService.castVote(proposal.id, support, amount);
      
      // Refresh proposal state after voting
      const newState = await contractService.getProposalState(proposal.id);
      setProposalState(newState);
      
      // Close dialogs
      setVoteForDialogOpen(false);
      setVoteAgainstDialogOpen(false);
      setVoteAmount('');
    } catch (error) {
      console.error('Error casting vote:', error);
    } finally {
      setLoading(false);
    }
  };

  if (!proposalState) {
    return (
      <Card>
        <CardContent>
          <Box display="flex" justifyContent="center" p={3}>
            <CircularProgress />
          </Box>
        </CardContent>
      </Card>
    );
  }

  const totalVotes = proposalState.forVotes.add(proposalState.againstVotes);
  const forPercentage = totalVotes.gt(0)
    ? proposalState.forVotes.mul(100).div(totalVotes).toNumber()
    : 0;
  const againstPercentage = 100 - forPercentage;

  const isVotingActive = proposalState.state === ProposalState.Active;

  return (
    <Card>
      <CardHeader
        title={
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
            <Typography variant="h6">
              {proposal.title}
              <Typography
                component="span"
                variant="subtitle2"
                sx={{ ml: 1, color: 'text.secondary' }}
              >
                #{proposal.id}
              </Typography>
            </Typography>
          </Box>
        }
        subheader={
          <Box sx={{ mt: 1 }}>
            <Typography variant="body2" color="text.secondary">
              {proposal.description}
            </Typography>
            <Box sx={{ 
              display: 'flex', 
              alignItems: 'center', 
              gap: 2, 
              mt: 1,
              color: 'text.secondary'
            }}>
              <Box sx={{ display: 'flex', alignItems: 'center' }}>
                <Timer size={16} sx={{ mr: 1 }} />
                {timeRemaining}
              </Box>
              <Box sx={{ display: 'flex', alignItems: 'center' }}>
                <Users size={16} sx={{ mr: 1 }} />
                {totalVotes.toString()} votes
              </Box>
            </Box>
          </Box>
        }
      />

      <CardContent>
        {/* Voting Progress */}
        <Box sx={{ mb: 4 }}>
          {/* For Votes */}
          <Box sx={{ mb: 2 }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
              <Typography variant="body2">For</Typography>
              <Typography variant="body2">{forPercentage}%</Typography>
            </Box>
            <LinearProgress 
              variant="determinate" 
              value={forPercentage}
              sx={{
                height: 8,
                backgroundColor: 'error.light',
                '& .MuiLinearProgress-bar': {
                  backgroundColor: 'success.main'
                }
              }}
            />
            <Typography variant="body2" color="text.secondary" sx={{ mt: 0.5 }}>
              {ethers.utils.formatEther(proposalState.forVotes)} votes
            </Typography>
          </Box>

          {/* Against Votes */}
          <Box sx={{ mb: 2 }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
              <Typography variant="body2">Against</Typography>
              <Typography variant="body2">{againstPercentage}%</Typography>
            </Box>
            <LinearProgress 
              variant="determinate" 
              value={againstPercentage}
              sx={{
                height: 8,
                backgroundColor: 'success.light',
                '& .MuiLinearProgress-bar': {
                  backgroundColor: 'error.main'
                }
              }}
            />
            <Typography variant="body2" color="text.secondary" sx={{ mt: 0.5 }}>
              {ethers.utils.formatEther(proposalState.againstVotes)} votes
            </Typography>
          </Box>
        </Box>

        {/* Voting Actions */}
        <Box sx={{ 
          display: 'flex', 
          justifyContent: 'space-between', 
          mt: 2 
        }}>
          {isVotingActive && (
            <>
              <Button
                variant="outlined"
                color="error"
                onClick={() => setVoteAgainstDialogOpen(true)}
                disabled={loading}
                startIcon={<ThumbsDown />}
                sx={{ flex: 1, mr: 1 }}
              >
                Vote Against
              </Button>
              <Button
                variant="contained"
                color="success"
                onClick={() => setVoteForDialogOpen(true)}
                disabled={loading}
                startIcon={<ThumbsUp />}
                sx={{ flex: 1, ml: 1 }}
              >
                Vote For
              </Button>
            </>
          )}
        </Box>

        {/* Vote For Dialog */}
        <Dialog 
          open={voteForDialogOpen} 
          onClose={() => setVoteForDialogOpen(false)}
        >
          <DialogTitle>Cast Vote For Proposal</DialogTitle>
          <DialogContent>
            <DialogContentText sx={{ mb: 2 }}>
              Enter the amount of tokens you want to vote with:
            </DialogContentText>
            <TextField
              label="Vote Amount"
              type="number"
              value={voteAmount}
              onChange={(e) => setVoteAmount(e.target.value)}
              fullWidth
              sx={{ mb: 2 }}
            />
            <DialogContentText color="warning.main">
              This action cannot be undone.
            </DialogContentText>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setVoteForDialogOpen(false)}>Cancel</Button>
            <Button
              onClick={() => handleVote(true)}
              variant="contained"
              color="success"
              disabled={loading || !voteAmount}
            >
              {loading ? <Loader2 className="animate-spin" /> : 'Confirm Vote'}
            </Button>
          </DialogActions>
        </Dialog>

        {/* Vote Against Dialog */}
        <Dialog 
          open={voteAgainstDialogOpen} 
          onClose={() => setVoteAgainstDialogOpen(false)}
        >
          <DialogTitle>Cast Vote Against Proposal</DialogTitle>
          <DialogContent>
            <DialogContentText sx={{ mb: 2 }}>
              Enter the amount of tokens you want to vote with:
            </DialogContentText>
            <TextField
              label="Vote Amount"
              type="number"
              value={voteAmount}
              onChange={(e) => setVoteAmount(e.target.value)}
              fullWidth
              sx={{ mb: 2 }}
            />
            <DialogContentText color="warning.main">
              This action cannot be undone.
            </DialogContentText>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setVoteAgainstDialogOpen(false)}>Cancel</Button>
            <Button
              onClick={() => handleVote(false)}
              variant="contained"
              color="error"
              disabled={loading || !voteAmount}
            >
              {loading ? <Loader2 className="animate-spin" /> : 'Confirm Vote'}
            </Button>
          </DialogActions>
        </Dialog>
      </CardContent>
    </Card>
  );
};

export default VotingInterface;
=== ./DAODashboard.tsx ===
import React, { useEffect, useState } from 'react';
import { ContractService } from './contractService';
import { ethers } from 'ethers';

import { 
  Card,
  CardHeader,
  CardContent,
  Typography,
  Alert,
  AlertTitle,
  CircularProgress,
  Box,
  Grid
} from '@mui/material';

import { 
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  LineChart,
  Line 
} from 'recharts';

import { Loader2, TrendingUp, Users, FileText, Activity } from 'lucide-react';

// Import subcomponents
import ProposalCreation from './ProposalCreation';
import ProposalList from './ProposalList';
import VotingInterface from './VotingInterface';
import TokenMetrics from './TokenMetrics';
import MembershipStats from './MembershipStats';

const DAODashboard = () => {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [daoStatus, setDaoStatus] = useState(null);
  const [contractService, setContractService] = useState(null);
  const [refreshKey, setRefreshKey] = useState(0);

  // Initialize contract service and set up data fetching
  useEffect(() => {
    const initializeContract = async () => {
      try {
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const service = new ContractService(
          provider,
          '0x23767A0C9A072C6A081C27A1C03Cc95B9F9cc6E0' // Contract address
        );
        setContractService(service);

        // Initial data fetch
        await fetchDAOStatus(service);
      } catch (error) {
        console.error('Error initializing dashboard:', error);
        setError('Failed to initialize DAO dashboard. Please check your wallet connection.');
        setLoading(false);
      }
    };

    initializeContract();
  }, []);

  // Set up periodic data refresh
  useEffect(() => {
    if (!contractService) return;

    const fetchData = () => {
      fetchDAOStatus(contractService);
    };

    // Refresh every 30 seconds
    const interval = setInterval(fetchData, 30000);
    return () => clearInterval(interval);
  }, [contractService]);

  // Function to fetch DAO status data
  const fetchDAOStatus = async (service) => {
    try {
      const status = await service.getDAOStatus();
      
      // Calculate additional metrics
      const currentTime = Math.floor(Date.now() / 1000);
      const epochAge = currentTime - status.lastEpochUpdate;
      const epochProgress = (epochAge / (24 * 60 * 60)) * 100; // Assuming 1 epoch = 1 day

      // Transform analytics data for visualization
      const analyticsData = [
        { name: 'Transactions', value: status.analytics.transactions },
        { name: 'Active Users', value: status.analytics.users },
        { name: 'Votes Cast', value: status.analytics.votes }
      ];

      setDaoStatus({
        ...status,
        epochProgress,
        analyticsData
      });
      setLoading(false);
    } catch (error) {
      console.error('Error fetching DAO status:', error);
      setError('Failed to fetch latest DAO status');
      setLoading(false);
    }
  };

  // Handle wallet disconnect/network change
  useEffect(() => {
    const handleAccountsChanged = () => {
      setRefreshKey(prev => prev + 1);
    };

    window.ethereum?.on('accountsChanged', handleAccountsChanged);
    window.ethereum?.on('chainChanged', handleAccountsChanged);

    return () => {
      window.ethereum?.removeListener('accountsChanged', handleAccountsChanged);
      window.ethereum?.removeListener('chainChanged', handleAccountsChanged);
    };
  }, []);

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '50vh' }}>
        <Box sx={{ textAlign: 'center' }}>
          <CircularProgress size={40} sx={{ mb: 2 }} />
          <Typography variant="h6">Loading DAO Data...</Typography>
        </Box>
      </Box>
    );
  }

  if (error) {
    return (
      <Alert severity="error" sx={{ m: 2 }}>
        <AlertTitle>Error</AlertTitle>
        {error}
      </Alert>
    );
  }

  return (
    <div className="container mx-auto p-6 space-y-6">
      {/* Overview Cards */}
      <Grid container spacing={3}>
        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent>
              <Box sx={{ mb: 2 }}>
                <FileText size={24} />
              </Box>
              <Typography variant="h5" component="div">
                {daoStatus.proposalCount}
              </Typography>
              <Typography color="text.secondary">
                Total Proposals
              </Typography>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent>
              <Box sx={{ mb: 2 }}>
                <Users size={24} />
              </Box>
              <Typography variant="h5" component="div">
                {daoStatus.activeUserCount}
              </Typography>
              <Typography color="text.secondary">
                Active Members
              </Typography>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent>
              <Box sx={{ mb: 2 }}>
                <Activity size={24} />
              </Box>
              <Typography variant="h5" component="div">
                {daoStatus.currentStage}
              </Typography>
              <Typography color="text.secondary">
                Current Stage
              </Typography>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent>
              <Box sx={{ mb: 2 }}>
                <TrendingUp size={24} />
              </Box>
              <Typography variant="h5" component="div">
                {daoStatus.analytics.velocity.toFixed(2)}
              </Typography>
              <Typography color="text.secondary">
                Network Velocity
              </Typography>
            </CardContent>
          </Card>
        </Grid>
      </Grid>

      {/* Main Content Grid */}
      <Grid container spacing={3}>
        {/* Left Column */}
        <Grid item xs={12} lg={8}>
          <Card sx={{ mb: 3 }}>
            <CardHeader title="Activity Analytics" />
            <CardContent sx={{ height: 300 }}>
              <ResponsiveContainer width="100%" height="100%">
                <BarChart data={daoStatus.analyticsData}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="name" />
                  <YAxis />
                  <Tooltip />
                  <Legend />
                  <Bar dataKey="value" fill="#8884d8" />
                </BarChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>

          <Card>
            <CardHeader title="Epoch Progress" />
            <CardContent>
              <Box sx={{ position: 'relative', pt: 1 }}>
                <Box sx={{ 
                  width: '100%', 
                  height: 4, 
                  bgcolor: 'background.paper',
                  borderRadius: 2
                }}>
                  <Box
                    sx={{
                      width: `${daoStatus.epochProgress}%`,
                      height: '100%',
                      bgcolor: 'primary.main',
                      borderRadius: 2,
                      transition: 'width 0.5s ease-in-out'
                    }}
                  />
                </Box>
                <Typography variant="caption" sx={{ mt: 1, display: 'block' }}>
                  Current Epoch: {daoStatus.currentEpoch} 
                  ({daoStatus.epochProgress.toFixed(1)}% complete)
                </Typography>
              </Box>
            </CardContent>
          </Card>
        </Grid>

        {/* Right Column */}
        <Grid item xs={12} lg={4}>
          <TokenMetrics key={`token-${refreshKey}`} />
          <Box sx={{ mt: 3 }}>
            <MembershipStats key={`members-${refreshKey}`} />
          </Box>
        </Grid>
      </Grid>

      {/* Proposal Section */}
      <Grid container spacing={3}>
        <Grid item xs={12}>
          <Card>
            <CardHeader title="Recent Proposals" />
            <CardContent>
              <ProposalList key={`proposals-${refreshKey}`} />
            </CardContent>
          </Card>
        </Grid>
      </Grid>
    </div>
  );
};

export default DAODashboard;
=== ./allfiles.txt ===
=== ./AnonymousTransactions.tsx ===
import React, { useState, useEffect } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  TextField,
  Button,
  Tabs,
  Tab,
  Paper,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  CircularProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Alert,
  Snackbar,
  Stack
} from '@mui/material';

// Placeholder data for development
const PLACEHOLDER_TRANSACTIONS = [
  {
    txHash: '0x1234...5678',
    recipient: '0xabcd...ef12',
    amount: '1000',
    creationTime: Date.now() - 86400000,
    claimed: false,
    condition: 'Time lock until 2024-02-01'
  },
  {
    txHash: '0x5678...9012',
    recipient: '0xef12...3456',
    amount: '500',
    creationTime: Date.now() - 172800000,
    claimed: true,
    condition: 'Requires specific signature'
  }
];

const AnonymousTransactions = () => {
  // State management
  const [currentTab, setCurrentTab] = useState(0);
  const [loading, setLoading] = useState(false);
  const [transactions, setTransactions] = useState(PLACEHOLDER_TRANSACTIONS);
  const [createDialogOpen, setCreateDialogOpen] = useState(false);
  const [claimDialogOpen, setClaimDialogOpen] = useState(false);
  const [selectedTx, setSelectedTx] = useState(null);
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: '',
    severity: 'success'
  });

  // Form state for creating new transaction
  const [newTxForm, setNewTxForm] = useState({
    recipient: '',
    amount: '',
    condition: ''
  });

  // Form state for claiming transaction
  const [claimForm, setClaimForm] = useState({
    signature: '',
    condition: ''
  });

  const handleCreateTransaction = async () => {
    setLoading(true);
    try {
      // Placeholder for contract interaction
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Add new transaction to list (placeholder implementation)
      const newTx = {
        txHash: `0x${Math.random().toString(16).slice(2)}`,
        recipient: newTxForm.recipient,
        amount: newTxForm.amount,
        creationTime: Date.now(),
        claimed: false,
        condition: newTxForm.condition
      };
      
      setTransactions([newTx, ...transactions]);
      setCreateDialogOpen(false);
      setNewTxForm({ recipient: '', amount: '', condition: '' });
      
      setSnackbar({
        open: true,
        message: 'Transaction created successfully',
        severity: 'success'
      });
    } catch (error) {
      setSnackbar({
        open: true,
        message: 'Failed to create transaction',
        severity: 'error'
      });
    } finally {
      setLoading(false);
    }
  };

  const handleClaimTransaction = async (tx) => {
    setLoading(true);
    try {
      // Placeholder for contract interaction
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Update transaction status (placeholder implementation)
      const updatedTransactions = transactions.map(t => 
        t.txHash === tx.txHash ? { ...t, claimed: true } : t
      );
      
      setTransactions(updatedTransactions);
      setClaimDialogOpen(false);
      setClaimForm({ signature: '', condition: '' });
      
      setSnackbar({
        open: true,
        message: 'Transaction claimed successfully',
        severity: 'success'
      });
    } catch (error) {
      setSnackbar({
        open: true,
        message: 'Failed to claim transaction',
        severity: 'error'
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <Card>
      <CardContent>
        <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 2 }}>
          <Tabs value={currentTab} onChange={(e, v) => setCurrentTab(v)}>
            <Tab label="Transactions" />
            <Tab label="Create New" />
          </Tabs>
        </Box>

        {/* Transactions List Tab */}
        {currentTab === 0 && (
          <Box>
            <Paper sx={{ overflow: 'auto' }}>
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell>Transaction Hash</TableCell>
                    <TableCell>Recipient</TableCell>
                    <TableCell>Amount</TableCell>
                    <TableCell>Created</TableCell>
                    <TableCell>Status</TableCell>
                    <TableCell>Actions</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {transactions.map((tx) => (
                    <TableRow key={tx.txHash}>
                      <TableCell>{tx.txHash}</TableCell>
                      <TableCell>{tx.recipient}</TableCell>
                      <TableCell>{tx.amount} PITA</TableCell>
                      <TableCell>
                        {new Date(tx.creationTime).toLocaleDateString()}
                      </TableCell>
                      <TableCell>
                        {tx.claimed ? (
                          <Alert severity="success" sx={{ py: 0 }}>Claimed</Alert>
                        ) : (
                          <Alert severity="info" sx={{ py: 0 }}>Pending</Alert>
                        )}
                      </TableCell>
                      <TableCell>
                        {!tx.claimed && (
                          <Button
                            variant="outlined"
                            onClick={() => {
                              setSelectedTx(tx);
                              setClaimDialogOpen(true);
                            }}
                          >
                            Claim
                          </Button>
                        )}
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </Paper>
          </Box>
        )}

        {/* Create Transaction Tab */}
        {currentTab === 1 && (
          <Box sx={{ mt: 2 }}>
            <Stack spacing={3}>
              <Typography variant="subtitle1">
                Create New Anonymous Transaction
              </Typography>
              
              <TextField
                label="Recipient Address"
                value={newTxForm.recipient}
                onChange={(e) => setNewTxForm(prev => ({
                  ...prev,
                  recipient: e.target.value
                }))}
                fullWidth
              />
              
              <TextField
                label="Amount (PITA)"
                type="number"
                value={newTxForm.amount}
                onChange={(e) => setNewTxForm(prev => ({
                  ...prev,
                  amount: e.target.value
                }))}
                fullWidth
              />
              
              <TextField
                label="Condition (Optional)"
                value={newTxForm.condition}
                onChange={(e) => setNewTxForm(prev => ({
                  ...prev,
                  condition: e.target.value
                }))}
                multiline
                rows={2}
                fullWidth
                helperText="Add conditions for claiming this transaction"
              />
              
              <Button
                variant="contained"
                onClick={handleCreateTransaction}
                disabled={loading || !newTxForm.recipient || !newTxForm.amount}
              >
                {loading ? (
                  <CircularProgress size={24} />
                ) : (
                  'Create Anonymous Transaction'
                )}
              </Button>
            </Stack>
          </Box>
        )}

        {/* Claim Transaction Dialog */}
        <Dialog 
          open={claimDialogOpen} 
          onClose={() => setClaimDialogOpen(false)}
        >
          <DialogTitle>Claim Anonymous Transaction</DialogTitle>
          <DialogContent>
            <Stack spacing={3} sx={{ mt: 2, minWidth: 400 }}>
              <TextField
                label="Signature"
                value={claimForm.signature}
                onChange={(e) => setClaimForm(prev => ({
                  ...prev,
                  signature: e.target.value
                }))}
                fullWidth
                required
              />
              
              <TextField
                label="Condition Data"
                value={claimForm.condition}
                onChange={(e) => setClaimForm(prev => ({
                  ...prev,
                  condition: e.target.value
                }))}
                multiline
                rows={2}
                fullWidth
                required
              />
            </Stack>
          </DialogContent>
          <DialogActions>
            <Button 
              onClick={() => setClaimDialogOpen(false)}
              disabled={loading}
            >
              Cancel
            </Button>
            <Button
              variant="contained"
              onClick={() => handleClaimTransaction(selectedTx)}
              disabled={loading || !claimForm.signature}
            >
              {loading ? (
                <CircularProgress size={24} />
              ) : (
                'Claim Transaction'
              )}
            </Button>
          </DialogActions>
        </Dialog>

        {/* Snackbar for notifications */}
        <Snackbar
          open={snackbar.open}
          autoHideDuration={6000}
          onClose={() => setSnackbar(prev => ({ ...prev, open: false }))}
        >
          <Alert 
            onClose={() => setSnackbar(prev => ({ ...prev, open: false }))} 
            severity={snackbar.severity as 'success' | 'error'}
          >
            {snackbar.message}
          </Alert>
        </Snackbar>
      </CardContent>
    </Card>
  );
};

export default AnonymousTransactions;
=== ./ProposalList.tsx ===
// src/views/components/dashboard/ProposalList.tsx
import React from 'react';
import { 
  List,
  ListItem,
  ListItemText,
  Paper,
  Typography 
} from '@mui/material';
import { useProposals } from '../../../contexts/ProposalContext';

// First, let's define an interface for our component's props
interface ProposalListProps {
  proposals: Array<{
    id: string;
    title: string;
    description: string;
    // Add other proposal properties as needed
  }>;
}

// Then we use this interface to type our component
const ProposalList: React.FC<ProposalListProps> = ({ proposals }) => {
  // We can still use the context to get additional proposals if needed
  const { activeProposals } = useProposals();
  
  // Combine passed proposals with active proposals if desired
  const allProposals = [...proposals, ...activeProposals];

  if (allProposals.length === 0) {
    return (
      <Paper sx={{ p: 2 }}>
        <Typography color="text.secondary">
          No active proposals
        </Typography>
      </Paper>
    );
  }

  return (
    <List>
      {allProposals.map(proposal => (
        <ListItem key={proposal.id}>
          <ListItemText
            primary={proposal.title}
            secondary={proposal.description}
          />
        </ListItem>
      ))}
    </List>
  );
}

export default ProposalList;
=== ./MembershipStats.tsx ===
import React, { useEffect, useState } from 'react';
import { ContractService } from './contractService';
import { ethers } from 'ethers';
import { 
  Card,
  CardHeader,
  CardContent,
  Typography,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  Paper,
  CircularProgress,
  Box
} from '@mui/material';

import {
  PieChart,
  Pie,
  Cell,
  ResponsiveContainer,
  Tooltip
} from 'recharts';

import { Users, Vote, Wallet } from 'lucide-react';

const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042'];

const MembershipStats = () => {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [membershipData, setMembershipData] = useState({
    totalMembers: 0,
    activeMembersLast30Days: 0,
    averageParticipation: 0,
    recentMembers: [],
    memberCategories: []
  });

  useEffect(() => {
    const fetchMembershipData = async () => {
      try {
        setLoading(true);
        
        // Initialize provider and contract service
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const contractService = new ContractService(
          provider,
          '0x23767A0C9A072C6A081C27A1C03Cc95B9F9cc6E0' // Your contract address
        );

        const currentTimestamp = Math.floor(Date.now() / 1000);
        const thirtyDaysAgo = currentTimestamp - (30 * 24 * 60 * 60);

        // We'll accumulate member data by checking each address's status
        let activeCount = 0;
        let recentMembers = [];

        // Fetch active user count from contract
        const activeUserCount = await contractService.contract.activeUserCount();

        // Iterate through active users to get their details
        for(let i = 0; i < activeUserCount; i++) {
          const address = await contractService.contract.activeUserIndex(i);
          const memberStatus = await contractService.getMembershipStatus(address);
          
          if(memberStatus.lastActivity > thirtyDaysAgo) {
            activeCount++;
          }

          // Add to recent members if they joined in last 7 days
          if(memberStatus.lastActivity > currentTimestamp - (7 * 24 * 60 * 60)) {
            recentMembers.push({
              address,
              joinDate: memberStatus.lastActivity,
              biddingShares: memberStatus.biddingShares
            });
          }
        }

        // Calculate participation rate
        const participationRate = (activeCount / activeUserCount.toNumber()) * 100;

        // Update state with real data
        setMembershipData({
          totalMembers: activeUserCount.toNumber(),
          activeMembersLast30Days: activeCount,
          averageParticipation: participationRate,
          recentMembers,
          memberCategories: [
            { 
              name: 'Regular Members', 
              value: activeUserCount.toNumber() - activeCount,
              color: '#0088FE'
            },
            { 
              name: 'Active Members', 
              value: activeCount,
              color: '#00C49F' 
            }
          ]
        });

        setLoading(false);
      } catch (error) {
        console.error('Error fetching membership data:', error);
        setError(error.message);
        setLoading(false);
      }
    };

    fetchMembershipData();
    const interval = setInterval(fetchMembershipData, 300000); // Update every 5 minutes
    return () => clearInterval(interval);
  }, []);

  if (loading) {
    return (
      <Card>
        <CardHeader>
          <Typography variant="h6">Membership Statistics</Typography>
        </CardHeader>
        <CardContent>
          <Box display="flex" justifyContent="center" alignItems="center" minHeight={200}>
            <CircularProgress />
          </Box>
        </CardContent>
      </Card>
    );
  }

  if (error) {
    return (
      <Card>
        <CardHeader>
          <Typography variant="h6">Membership Statistics</Typography>
        </CardHeader>
        <CardContent>
          <Typography color="error">{error}</Typography>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <Typography variant="h6">Membership Statistics</Typography>
      </CardHeader>
      <CardContent>
        {/* Overview Stats */}
        <Box sx={{ 
          display: 'grid', 
          gridTemplateColumns: 'repeat(3, 1fr)', 
          gap: 2,
          mb: 4 
        }}>
          <Box>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
              <Users className="mr-2" size={20} />
              <Typography variant="body2" color="text.secondary">
                Total Members
              </Typography>
            </Box>
            <Typography variant="h4">
              {membershipData.totalMembers.toLocaleString()}
            </Typography>
          </Box>

          <Box>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
              <Vote className="mr-2" size={20} />
              <Typography variant="body2" color="text.secondary">
                Active (30d)
              </Typography>
            </Box>
            <Typography variant="h4">
              {membershipData.activeMembersLast30Days.toLocaleString()}
            </Typography>
          </Box>

          <Box>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
              <Wallet className="mr-2" size={20} />
              <Typography variant="body2" color="text.secondary">
                Participation
              </Typography>
            </Box>
            <Typography variant="h4">
              {membershipData.averageParticipation.toFixed(1)}%
            </Typography>
          </Box>
        </Box>

        {/* Member Categories Pie Chart */}
        <Box sx={{ height: 300, mb: 4 }}>
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <Pie
                data={membershipData.memberCategories}
                dataKey="value"
                nameKey="name"
                cx="50%"
                cy="50%"
                outerRadius={80}
                label
              >
                {membershipData.memberCategories.map((entry, index) => (
                  <Cell key={`cell-${index}`} fill={entry.color} />
                ))}
              </Pie>
              <Tooltip />
            </PieChart>
          </ResponsiveContainer>
        </Box>

        {/* Recent Members Table */}
        <Box>
          <Typography variant="h6" sx={{ mb: 2 }}>Recent Members</Typography>
          <Paper sx={{ width: '100%', overflow: 'hidden' }}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Address</TableCell>
                  <TableCell>Joined</TableCell>
                  <TableCell>Bidding Shares</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {membershipData.recentMembers.map((member) => (
                  <TableRow key={member.address}>
                    <TableCell>{member.address}</TableCell>
                    <TableCell>
                      {new Date(member.joinDate * 1000).toLocaleDateString()}
                    </TableCell>
                    <TableCell>{member.biddingShares}%</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </Paper>
        </Box>
      </CardContent>
    </Card>
  );
};

export default MembershipStats;
=== ./DAOPage.txt ===
import React, { useState } from 'react';
import { useContractEvents } from 'hooks/useContractEvents';

import { 
  Card,
  CardHeader,
  CardContent,
  Typography,
  Alert,
  AlertTitle,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  Paper,
  Button,
  Tabs,
  Tab,
  Box,
  CircularProgress
} from '@mui/material';

import { 
  LayoutDashboard,
  Vote,
  Wallet,
  Users,
  Settings,
  AlertCircle
} from 'lucide-react';
import { ethers } from 'ethers';

import DAODashboard from './DAODashboard';
import ProposalCreation from './ProposalCreation';
import VotingInterface from './VotingInterface';
import TokenMetrics from './TokenMetrics';
import MembershipStats from './MembershipStats';

import { useWeb3React } from 'hooks/useWeb3ReactProvider';
import { injected } from '../../../connectors/injected';
import { CustomConnectButton } from 'components/ConnectButton';

// Create a TabPanel component to handle content display
function TabPanel(props: {
  children?: React.ReactNode;
  value: string;
  index: string;
}) {
  const { children, value, index } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
    >
      {value === index && (
        <Box sx={{ py: 3 }}>
          {children}
        </Box>
      )}
    </div>
  );
}

const DAOPage = () => {
  const { isInitialized, error: contractError } = useContractEvents();
  const { 
    active,
    connect,
    error: web3Error,
    isActivating,
    chainId 
  } = useWeb3React();
  
  const [currentTab, setCurrentTab] = useState('dashboard');
  
  const handleTabChange = (event: React.SyntheticEvent, newValue: string) => {
    setCurrentTab(newValue);
  };

  const connectWallet = async () => {
    try {
      await connect();
    } catch (error) {
      console.error('Failed to connect wallet:', error);
    }
  };
  
  console.log('DAOPage: Render state', {
    isInitialized,
    hasError: !!contractError,
    errorMessage: contractError?.message,
    isWalletConnected: active
  });

  // Check if we're on PulseChain
  const isPulseChain = chainId === 369 || chainId === 943;
  
  /*if (!active || !isPulseChain) {
    return (
      <div className="flex h-screen items-center justify-center">
        <div className="text-center">
          <h2 className="mb-4 text-xl font-semibold">Connect Your Wallet</h2>
          {web3Error && (
            <p className="mb-4 text-red-500">
              {web3Error.message}
            </p>
          )}
          <Button 
            onClick={connectWallet}
            disabled={isActivating}
            className="px-6 py-2"
          >
            {isActivating ? 'Connecting...' : 'Connect Wallet'}
          </Button>
          {active && !isPulseChain && (
            <p className="mt-2 text-sm text-red-500">
              Please switch to PulseChain network
            </p>
          )}
        </div>
      </div>
    );
  }*/
  
  if (!active || !isPulseChain) {
    return (
      <div className="flex h-screen items-center justify-center">
        <div className="text-center">
          <h2 className="mb-4 text-xl font-semibold">Connect Your Wallet</h2>
          <CustomConnectButton />
        </div>
      </div>
    );
  }

  // Only show loading state if wallet is connected but contracts aren't initialized
  if (!isInitialized && !contractError) {
    return (
      <div className="flex h-screen items-center justify-center">
        <div className="text-center">
          <div className="mb-4 h-8 w-8 animate-spin rounded-full border-b-2 border-t-2 border-blue-500"></div>
          <h2 className="text-xl font-semibold">
            Initializing DAO Interface...
          </h2>
        </div>
      </div>
    );
  }

  if (contractError) {
    return (
      <Box sx={{ p: 3 }}>
        <Alert severity="error">
          <AlertTitle>Error</AlertTitle>
          <Typography>
            {contractError.message}
            <Button 
              variant="text"
              onClick={() => window.location.reload()}
              sx={{ mt: 2, display: 'block' }}
            >
              Try refreshing the page
            </Button>
          </Typography>
        </Alert>
      </Box>
    );
  }

  return (
    <Box sx={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
      {/* Navigation Header */}
      <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
        <Box sx={{ 
          maxWidth: 'lg', 
          mx: 'auto', 
          height: 64, 
          display: 'flex', 
          alignItems: 'center',
          px: 3
        }}>
          <Typography variant="h6">DAO Dashboard</Typography>
        </Box>
      </Box>

      {/* Main Content */}
      <Box sx={{ flex: 1, p: 3 }}>
        <Box sx={{ display: 'flex', gap: 3 }}>
          {/* Sidebar Navigation */}
          <Box sx={{ width: 240, flexShrink: 0 }}>
            <Tabs
              orientation="vertical"
              value={currentTab}
              onChange={handleTabChange}
              sx={{
                borderRight: 1,
                borderColor: 'divider',
                '& .MuiTab-root': {
                  justifyContent: 'flex-start',
                  textAlign: 'left',
                  alignItems: 'center',
                  gap: 1
                }
              }}
            >
              <Tab 
                icon={<LayoutDashboard />} 
                label="Overview" 
                value="dashboard"
                iconPosition="start"
              />
              <Tab 
                icon={<Vote />} 
                label="Proposals" 
                value="proposals"
                iconPosition="start"
              />
              <Tab 
                icon={<Wallet />} 
                label="Treasury" 
                value="treasury"
                iconPosition="start"
              />
              <Tab 
                icon={<Users />} 
                label="Members" 
                value="members"
                iconPosition="start"
              />
              <Tab 
                icon={<Settings />} 
                label="Settings" 
                value="settings"
                iconPosition="start"
              />
            </Tabs>

            <Button
              variant="contained"
              fullWidth
              sx={{ mt: 2 }}
            >
              Connect Wallet
            </Button>
          </Box>

          {/* Main Content Area */}
          <Box sx={{ flex: 1 }}>
            <TabPanel value={currentTab} index="dashboard">
              <DAODashboard />
            </TabPanel>

            <TabPanel value={currentTab} index="proposals">
              <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
                <ProposalCreation />
                <VotingInterface proposal={{
                  id: "1",
                  title: "Example Proposal",
                  description: "This is an example proposal",
                  proposer: "0x1234...5678",
                  startTime: Date.now() / 1000,
                  endTime: (Date.now() / 1000) + 86400,
                  forVotes: ethers.BigNumber.from("1000000"),
                  againstVotes: ethers.BigNumber.from("500000"),
                  executed: false,
                  category: 1
                }} />
              </Box>
            </TabPanel>

            <TabPanel value={currentTab} index="treasury">
              <TokenMetrics />
            </TabPanel>

            <TabPanel value={currentTab} index="members">
              <MembershipStats />
            </TabPanel>

            <TabPanel value={currentTab} index="settings">
              <Card>
                <CardContent>
                  <Typography variant="h6">DAO Settings</Typography>
                  <Typography color="textSecondary" sx={{ mt: 1 }}>
                    Configure your DAO preferences and parameters.
                  </Typography>
                </CardContent>
              </Card>
            </TabPanel>
          </Box>
        </Box>
      </Box>

      {/* Footer */}
      <Box sx={{ 
        borderTop: 1, 
        borderColor: 'divider',
        p: 2,
        mt: 'auto'
      }}>
        <Typography color="textSecondary" variant="body2">
          Running on PulseChain Network • Block: #1234567
        </Typography>
      </Box>
    </Box>
  );
};

export default DAOPage;
=== ./DAOPage.tsx ===
import React, { useState, useEffect } from 'react';
//import { useContractEvents } from 'hooks/useContractEvents';
//import { useWeb3React } from 'hooks/useWeb3ReactProvider';

import { useWeb3React } from 'hooks/useWeb3ReactProvider';
import { useContractEvents } from 'hooks/useContractEvents';
import { useWeb3Manager } from 'hooks/useWeb3Manager';

import { 
  Card,
  CardHeader,
  CardContent,
  Typography,
  Alert,
  AlertTitle,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  Paper,
  Button,
  Tabs,
  Tab,
  Box,
  CircularProgress,
  Stack,  // Added this
  Chip    // Added this
} from '@mui/material';

import { 
  LayoutDashboard,
  Vote,
  Wallet,
  Users,
  Settings,
  AlertCircle
} from 'lucide-react';
import { ethers } from 'ethers';

import DAODashboard from './DAODashboard';
import ProposalCreation from './ProposalCreation';
import VotingInterface from './VotingInterface';
import TokenMetrics from './TokenMetrics';
import MembershipStats from './MembershipStats';
import AnonymousTransactions from './AnonymousTransactions';

// Create a TabPanel component to handle content display
function TabPanel(props: {
  children?: React.ReactNode;
  value: string;
  index: string;
}) {
  const { children, value, index } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
    >
      {value === index && (
        <Box sx={{ py: 3 }}>
          {children}
        </Box>
      )}
    </div>
  );
}

const WalletConnection = () => {
  const {
    connectionStatus,
    startInitialization,
    web3State: { account, chainId },
    isInitialized: connectionInitialized  // Rename to avoid confusion
  } = useWeb3Manager();

  // Get initialize function from useContractEvents
  const { initialize } = useContractEvents();

const handleConnect = async () => {
  try {
    console.log('handleConnect called, current state:', {
      connectionStatus,
      account,
      chainId
    });
    
    // First connect wallet
    await startInitialization();
    
    // Then initialize contracts if wallet connection was successful
    if (connectionStatus === 'connected') {
      console.log('Calling initialize after successful connection');
      await initialize();
      console.log('Initialize call completed');
    } else {
      console.log('Not initializing - connection status:', connectionStatus);
    }
  } catch (error) {
    console.error('Connection/initialization error:', error);
  }
};

  // Add useEffect to handle automatic initialization when wallet is already connected
  useEffect(() => {
    const initializeContracts = async () => {
      console.log('initializeContracts effect triggered:', {
        connectionStatus,
        hasAccount: !!account,
        connectionInitialized  // Use renamed variable
      });

      if (connectionStatus === 'connected' && account) {
        try {
          console.log('Calling initialize from effect');
          await initialize();
          console.log('Initialize from effect completed');
        } catch (error) {
          console.error('Effect initialization error:', error);
        }
      }
    };

    initializeContracts();
  }, [connectionStatus, account, initialize, connectionInitialized]);

  const getConnectionDisplay = () => {
    switch (connectionStatus) {
      case 'connected':
        return (
          <Stack direction="row" spacing={2} alignItems="center">
            <Chip
              label={`Connected: ${account?.slice(0, 6)}...${account?.slice(-4)}`}
              color="success"
              sx={{ borderRadius: 1 }}
            />
            <Chip
              label={`Chain ID: ${chainId}`}
              color="primary"
              sx={{ borderRadius: 1 }}
            />
          </Stack>
        );
      case 'connecting':
        return (
          <Button
            variant="contained"
            fullWidth
            disabled
            sx={{ mt: 2 }}
          >
            <CircularProgress size={16} sx={{ mr: 1 }} />
            Connecting...
          </Button>
        );
      default:
        return (
          <Button
            variant="contained"
            fullWidth
            sx={{ mt: 2 }}
            onClick={handleConnect}
          >
            Connect Wallet
          </Button>
        );
    }
  };

  return (
    <Box>
      {getConnectionDisplay()}
    </Box>
  );
};

const DAOPage: React.FC = () => {
  // Get contract-related state and errors
  /*const { 
    isInitialized,
    error: contractError,  // Renamed for clarity
    initialize: initializeContracts 
  } = useContractEvents();*/
  
  const { 
    error: contractError,  // Renamed for clarity
  } = useContractEvents();
  
  const {
    isInitialized,
    contracts,
    error,
    startInitialization,
    isWalletConnecting,
    web3State
  } = useWeb3Manager();

  // Get wallet-related state and errors
  const { 
    isActive,
    connect,
    error: walletError,  // Renamed for clarity
    isActivating,
    chainId,
    account
  } = useWeb3React();

  const [currentTab, setCurrentTab] = useState('dashboard');

  // Updated logging to use the correct error references
  console.log('DAOPage: Render state', {
    isInitialized,
    hasContractError: !!contractError,
    contractErrorMessage: contractError?.message,
    hasWalletError: !!walletError,
    walletErrorMessage: walletError?.message,
    isWalletConnected: isActive
  });
  
  const handleConnect = async () => {
    try {
      // Start the initialization process
      await startInitialization();
    } catch (error) {
      console.error('Failed to start initialization:', error);
    }
  };

  const Header = () => (
    <Box sx={{ 
      borderBottom: 1, 
      borderColor: 'divider',
      p: 2,
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center'
    }}>
      <Typography variant="h6">DAO Dashboard</Typography>
      {/*<Button 
        variant="contained"
        onClick={handleConnect}
      >
        Connect Wallet
      </Button>*/}
    </Box>
  );

  // Check if we're on PulseChain
  const isPulseChain = chainId === 369 || chainId === 943;

  // Handle tab change
  const handleTabChange = (event: React.SyntheticEvent, newValue: string) => {
    setCurrentTab(newValue);
  };

  // Show contract error if present
  /*if (contractError) {
    return (
      <Box sx={{ p: 3 }}>
        <Alert severity="error">
          <AlertTitle>Error</AlertTitle>
          <Typography>
            {contractError.message}
            <Button 
              variant="text"
              onClick={() => window.location.reload()}
              sx={{ mt: 2, display: 'block' }}
            >
              Try refreshing the page
            </Button>
          </Typography>
        </Alert>
      </Box>
    );
  }*/
  
  /*if (isActive && !isInitialized && !contractError) {
    return (
      <div className="flex h-screen items-center justify-center">
        <div className="text-center">
          <div className="mb-4 h-8 w-8 animate-spin rounded-full border-b-2 border-t-2 border-blue-500"></div>
          <h2 className="text-xl font-semibold">
            Initializing DAO Interface...
          </h2>
        </div>
      </div>
    );
  }*/

  /*if (error) {
    return (
      <Box sx={{ p: 3 }}>
        <Alert severity="error">
          <AlertTitle>Error</AlertTitle>
          <Typography>
            {error.message}
            <Button 
              variant="text"
              onClick={() => window.location.reload()}
              sx={{ mt: 2, display: 'block' }}
            >
              Try refreshing the page
            </Button>
          </Typography>
        </Alert>
      </Box>
    );
  }*/

  return (
    <Box sx={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
      <Header />

      {/* Main Content */}
      <Box sx={{ flex: 1, p: 3 }}>
        <Box sx={{ display: 'flex', gap: 3 }}>
          {/* Sidebar Navigation */}
          <Box sx={{ width: 240, flexShrink: 0 }}>
            <Tabs
              orientation="vertical"
              value={currentTab}
              onChange={handleTabChange}
              sx={{
                borderRight: 1,
                borderColor: 'divider',
                '& .MuiTab-root': {
                  justifyContent: 'flex-start',
                  textAlign: 'left',
                  alignItems: 'center',
                  gap: 1
                }
              }}
            >
              <Tab 
                icon={<LayoutDashboard />} 
                label="Overview" 
                value="dashboard"
                iconPosition="start"
              />
              <Tab 
                icon={<Vote />} 
                label="Proposals" 
                value="proposals"
                iconPosition="start"
              />
              <Tab 
                icon={<Wallet />} 
                label="Treasury" 
                value="treasury"
                iconPosition="start"
              />
              <Tab 
                icon={<Users />} 
                label="Members" 
                value="members"
                iconPosition="start"
              />
              <Tab 
                icon={<Settings />} 
                label="Settings" 
                value="settings"
                iconPosition="start"
              />
              <Tab 
                label="Anonymous Transactions" 
                value="anontransact"
                iconPosition="start"
              /> {/*icon={<AnonymousTransactions />} */}
            </Tabs>

            <WalletConnection/>
          </Box>

          {/* Main Content Area */}
          <Box sx={{ flex: 1 }}>
            <TabPanel value={currentTab} index="dashboard">
              <DAODashboard />
            </TabPanel>

            <TabPanel value={currentTab} index="proposals">
              <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
                <ProposalCreation />
                <VotingInterface proposal={{
                  id: "1",
                  title: "Example Proposal",
                  description: "This is an example proposal",
                  proposer: "0x1234...5678",
                  startTime: Date.now() / 1000,
                  endTime: (Date.now() / 1000) + 86400,
                  forVotes: ethers.BigNumber.from("1000000"),
                  againstVotes: ethers.BigNumber.from("500000"),
                  executed: false,
                  category: 1
                }} />
              </Box>
            </TabPanel>

            <TabPanel value={currentTab} index="treasury">
              <TokenMetrics />
            </TabPanel>

            <TabPanel value={currentTab} index="members">
              <MembershipStats />
            </TabPanel>
            <TabPanel value={currentTab} index="anontransact">
              <AnonymousTransactions />
            </TabPanel>

            <TabPanel value={currentTab} index="settings">
              <Card>
                <CardContent>
                  <Typography variant="h6">DAO Settings</Typography>
                  <Typography color="textSecondary" sx={{ mt: 1 }}>
                    Configure your DAO preferences and parameters.
                  </Typography>
                </CardContent>
              </Card>
            </TabPanel>
          </Box>
        </Box>
      </Box>

      {/* Footer */}
      <Box sx={{ 
        borderTop: 1, 
        borderColor: 'divider',
        p: 2,
        mt: 'auto'
      }}>
        <Typography color="textSecondary" variant="body2">
          Running on PulseChain Network • Block: #1234567
        </Typography>
      </Box>
    </Box>
  );
};

export default DAOPage;
=== ./ProposalCreation.tsx ===
import React, { useState, useEffect } from 'react';
import { ContractService } from './contractService';
import { ethers } from 'ethers';
import {
  TextField,
  FormControl,
  FormLabel,
  Select,
  MenuItem,
  Button,
  Box,
  Grid,
  Paper,
  Typography,
  CircularProgress,
  Snackbar,
  Alert,
  AlertTitle,
  List,
  ListItem,
  ListItemText
} from '@mui/material';

// Proposal categories from contract
const PROPOSAL_CATEGORIES = [
  { id: 1, name: 'Governance', description: 'Changes to DAO rules and parameters' },
  { id: 2, name: 'Treasury', description: 'Fund allocation and financial decisions' },
  { id: 3, name: 'Technical', description: 'Smart contract upgrades and technical changes' },
  { id: 4, name: 'Community', description: 'Social and community initiatives' }
];

const ProposalCreation = () => {
  const [loading, setLoading] = useState(false);
  const [contractService, setContractService] = useState(null);
  const [currentEpoch, setCurrentEpoch] = useState(null);
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    category: '',
    votingPeriod: '7'
  });
  
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: '',
    severity: 'success'
  });

  // Initialize contract service
  useEffect(() => {
    const initializeContract = async () => {
      try {
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const service = new ContractService(
          provider,
          '0x23767A0C9A072C6A081C27A1C03Cc95B9F9cc6E0' // Contract address
        );
        setContractService(service);

        // Get current epoch for timing calculations
        const epoch = await service.getCurrentEpoch();
        setCurrentEpoch(epoch);
      } catch (error) {
        console.error('Error initializing contract:', error);
        setSnackbar({
          open: true,
          message: 'Failed to initialize contract connection',
          severity: 'error'
        });
      }
    };

    initializeContract();
  }, []);

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!contractService) return;

    setLoading(true);
    try {
      // Create proposal data object
      const proposalData = {
        title: formData.title,
        description: formData.description,
        category: parseInt(formData.category),
        votingPeriod: parseInt(formData.votingPeriod)
      };

      // Create proposal on-chain
      const proposalId = await contractService.createProposal(
        proposalData.category,
        proposalData.votingPeriod
      );

      setSnackbar({
        open: true,
        message: `Proposal created successfully with ID: ${proposalId}`,
        severity: 'success'
      });

      // Reset form
      setFormData({
        title: '',
        description: '',
        category: '',
        votingPeriod: '7'
      });
    } catch (error) {
      console.error('Error creating proposal:', error);
      setSnackbar({
        open: true,
        message: 'Failed to create proposal: ' + error.message,
        severity: 'error'
      });
    } finally {
      setLoading(false);
    }
  };

  // Calculate timing information for the UI
  const getTimingInfo = () => {
    if (!currentEpoch) return null;

    const startEpoch = currentEpoch + 1;
    const endEpoch = currentEpoch + (parseInt(formData.votingPeriod) * 24);
    const epochsToStart = startEpoch - currentEpoch;
    const votingDuration = endEpoch - startEpoch;

    return {
      startEpoch,
      endEpoch,
      epochsToStart,
      votingDuration
    };
  }

  const timingInfo = getTimingInfo();

  return (
    <Box component="form" onSubmit={handleSubmit} sx={{ '& > *': { mb: 3 } }}>
      <FormControl fullWidth>
        <FormLabel>Proposal Title</FormLabel>
        <TextField
          placeholder="Enter a clear, descriptive title"
          value={formData.title}
          onChange={(e) => setFormData(prev => ({
            ...prev,
            title: e.target.value
          }))}
          disabled={loading}
          required
          variant="outlined"
        />
      </FormControl>

      <FormControl fullWidth>
        <FormLabel>Description</FormLabel>
        <TextField
          placeholder="Provide a detailed description of your proposal"
          value={formData.description}
          onChange={(e) => setFormData(prev => ({
            ...prev,
            description: e.target.value
          }))}
          disabled={loading}
          required
          multiline
          rows={4}
          variant="outlined"
          helperText="Include background, rationale, and expected outcomes"
        />
      </FormControl>

      <Grid container spacing={2}>
        <Grid item xs={12} md={6}>
          <FormControl fullWidth>
            <FormLabel>Category</FormLabel>
            <Select
              value={formData.category}
              onChange={(e) => setFormData(prev => ({
                ...prev,
                category: e.target.value
              }))}
              disabled={loading}
              displayEmpty
            >
              <MenuItem value="" disabled>Select category</MenuItem>
              {PROPOSAL_CATEGORIES.map((category) => (
                <MenuItem 
                  key={category.id} 
                  value={category.id.toString()}
                >
                  <Box>
                    <Typography variant="body1">{category.name}</Typography>
                    <Typography variant="caption" color="text.secondary">
                      {category.description}
                    </Typography>
                  </Box>
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        </Grid>

        <Grid item xs={12} md={6}>
          <FormControl fullWidth>
            <FormLabel>Voting Period (days)</FormLabel>
            <TextField
              type="number"
              InputProps={{ 
                inputProps: { min: 1, max: 30 },
                endAdornment: <Typography variant="caption">days</Typography>
              }}
              value={formData.votingPeriod}
              onChange={(e) => setFormData(prev => ({
                ...prev,
                votingPeriod: e.target.value
              }))}
              disabled={loading}
              required
              variant="outlined"
              helperText="Recommended: 7 days for standard proposals"
            />
          </FormControl>
        </Grid>
      </Grid>

      {/* Timing Information */}
      {timingInfo && (
        <Paper sx={{ p: 2, mb: 3, bgcolor: 'background.default' }}>
          <Typography variant="subtitle1" sx={{ mb: 1 }}>
            Timing Information
          </Typography>
          <Grid container spacing={2}>
            <Grid item xs={6}>
              <Typography variant="body2" color="text.secondary">
                Start Epoch: {timingInfo.startEpoch}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                ({timingInfo.epochsToStart} epochs from now)
              </Typography>
            </Grid>
            <Grid item xs={6}>
              <Typography variant="body2" color="text.secondary">
                End Epoch: {timingInfo.endEpoch}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                (Duration: {timingInfo.votingDuration} epochs)
              </Typography>
            </Grid>
          </Grid>
        </Paper>
      )}

      {/* Preview Section */}
      {formData.title && formData.description && (
        <Paper sx={{ mt: 3, p: 2 }}>
          <Typography variant="subtitle1" sx={{ mb: 2 }}>Preview</Typography>
          <Box sx={{ '& > *': { mb: 1 } }}>
            <Typography variant="h6">
              {formData.title}
            </Typography>
            <Typography variant="body2" sx={{ whiteSpace: 'pre-wrap' }}>
              {formData.description}
            </Typography>
            <Box sx={{ 
              display: 'flex', 
              justifyContent: 'space-between',
              color: 'text.secondary',
              fontSize: '0.875rem',
              mt: 2
            }}>
              <span>
                Category: {PROPOSAL_CATEGORIES.find(c => 
                  c.id.toString() === formData.category
                )?.name}
              </span>
              <span>Voting Period: {formData.votingPeriod} days</span>
            </Box>
          </Box>
        </Paper>
      )}

      <Button 
        type="submit"
        variant="contained"
        fullWidth
        disabled={loading || !formData.title || !formData.description || !formData.category}
        sx={{ mt: 2 }}
      >
        {loading ? (
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <CircularProgress size={20} sx={{ mr: 1 }} />
            Creating Proposal...
          </Box>
        ) : (
          'Create Proposal'
        )}
      </Button>

      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={() => setSnackbar(prev => ({ ...prev, open: false }))}
      >
        <Alert 
          onClose={() => setSnackbar(prev => ({ ...prev, open: false }))} 
          severity={snackbar.severity}
          variant="filled"
          sx={{ width: '100%' }}
        >
          <AlertTitle>
            {snackbar.severity === 'success' ? 'Success' : 'Error'}
          </AlertTitle>
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default ProposalCreation;
