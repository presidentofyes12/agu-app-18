Home folder: /home/impromise/agu-app-no-errors/agu-app (1)/agu-app/src/views/components/dashboard/
 
=== ./ProposalIntegrationService.tsx ===
// src/views/components/dashboard/ProposalIntegrationService.tsx

import React, { useEffect, useState } from 'react';
import { ethers, BigNumber } from 'ethers';
import { ContractService, StateContractFunctions, DAOTokenFunctions } from './contractService';
import { 
    Address,
    Proposal,
    ProposalData,
    ContractInstances,
    IStateConstituent,
    IDAOToken,
    ILogicConstituent,
    IViewConstituent
} from 'types/contracts';
import { ProposalState } from 'services/ProposalLifecycle';

// Interface for the legacy Raven service
interface RavenService {
  fetchAllProposal(): Promise<LegacyProposal[]>;
  createChannel(proposal: LegacyProposalInput): Promise<any>;
  findChannel(id: string): Promise<Channel>;
  sendDirectMessage(channelId: string, content: string): Promise<void>;
  getChannelMessages(channelId: string): Promise<Message[]>;
}

// Legacy types that need to be maintained for backwards compatibility
interface LegacyProposal {
    id: string;
    content: string;
    created_at: number;
    category?: number;
    isPermanent?: boolean;  // New field to track permanent proposals
}

interface LegacyProposalInput {
    name: string;
    about: string;
    picture: string;
    isPermanent?: boolean;  // New field to track permanent proposals
}

interface Channel {
    id: string;
    name: string;
}

interface Message {
    id: string;
    content: string;
    timestamp: number;
}

// Extend ContractService to include Raven
interface ContractServiceWithRaven extends Omit<ContractService, 'contracts' | 'raven'> {
    raven?: RavenService & { updateReadMarkMap: () => void };
    contracts: {
        stateConstituent: ethers.Contract & IStateConstituent;
        daoToken: ethers.Contract & IDAOToken;
        logicConstituent: ethers.Contract & ILogicConstituent;
        viewConstituent?: ethers.Contract & IViewConstituent;
    };
}

export class ProposalIntegrationService {
    private contractService: ContractServiceWithRaven;
    private stateConstituent: IStateConstituent;

    constructor(contractService: ContractService) {
        // Verify that the contract service has all required constituents
        if (!this.verifyContractService(contractService)) {
            throw new Error('Contract service missing required constituents');
        }

        // Now we can safely cast
        this.contractService = contractService as ContractServiceWithRaven;
        this.stateConstituent = this.contractService.contracts.stateConstituent;
    }

    private verifyContractService(service: ContractService): boolean {
        const contracts = service.contracts;
        if (!contracts) return false;

        return !!(
            contracts.stateConstituent &&
            contracts.daoToken &&
            contracts.logicConstituent
        );
    }

    // Enhanced conversion to handle permanent proposals
    private convertLegacyProposal(legacy: LegacyProposal): Proposal {
        try {
            const parsedContent = JSON.parse(legacy.content);
            const about = JSON.parse(parsedContent.about);

            // Determine voting period based on permanent status
            const votingPeriod = legacy.isPermanent ? 
                BigNumber.from(365 * 24 * 60 * 60) :  // 1 year for permanent
                BigNumber.from(7 * 24 * 60 * 60);     // 1 week for regular

            return {
                id: legacy.id,
                creator: about.proposalID || legacy.id,
                title: parsedContent.name,
                description: about.problem || '',
                category: legacy.category || 0,
                createdAt: legacy.created_at,
                startEpoch: BigNumber.from(legacy.created_at),
                endEpoch: BigNumber.from(legacy.created_at).add(votingPeriod),
                executionDelay: BigNumber.from(0),
                currentState: ProposalState.ACTIVE,
                forVotes: BigNumber.from(0),
                againstVotes: BigNumber.from(0),
                quorum: BigNumber.from(0),
                isPermanent: legacy.isPermanent || false
            };
        } catch (error) {
            console.error('Error converting legacy proposal:', error);
            throw error;
        }
    }

  private async getOnChainProposal(id: string): Promise<Proposal> {
    const proposalData = await this.stateConstituent.getProposal(id);
    return this.convertProposalData(proposalData, id);
  }

  private convertProposalData(data: ProposalData, id: string): Proposal {
    return {
      id,
      creator: data.creator,
      title: data.title,
      description: data.description,
      category: data.category,
      createdAt: data.createdAt.toNumber(),
      startEpoch: data.startEpoch,
      endEpoch: data.endEpoch,
      executionDelay: data.executionDelay,
      currentState: data.currentState,
      forVotes: data.forVotes,
      againstVotes: data.againstVotes,
      quorum: data.quorum
    };
  }

    // Enhanced method to get all proposals
    async getAllProposals(): Promise<Proposal[]> {
        try {
            if (!this.contractService || !this.stateConstituent) {
                throw new Error('Contract service not properly initialized');
            }

            const [legacyProposals, onChainCount] = await Promise.all([
                this.contractService.raven?.fetchAllProposal() || [],
                this.stateConstituent.proposalCount()
            ]);

            // Convert legacy proposals with permanent status check
            const convertedLegacyProposals = legacyProposals.map(p => {
                // Check if this is a permanent proposal by name
                const parsedContent = JSON.parse(p.content);
                const isPermanent = this.isPermanentProposal(parsedContent.name);
                return this.convertLegacyProposal({
                    ...p,
                    isPermanent
                });
            });

            // Get on-chain proposals
            const onChainProposals = await Promise.all(
                Array.from({ length: onChainCount.toNumber() }, 
                    (_, i) => this.getOnChainProposal(i.toString())
                )
            );

            // Combine and deduplicate proposals
            return [...convertedLegacyProposals, ...onChainProposals]
                .filter((proposal, index, self) => 
                    index === self.findIndex(p => p.id === proposal.id)
                );

        } catch (error) {
            console.error('Error fetching proposals:', error);
            throw error;
        }
    }

    // Helper to identify permanent proposals
    private isPermanentProposal(name: string): boolean {
        const permanentProposals = [
            'Mostr',
            'Ephemeral Relays',
            'Public and private AI profiles for version control',
            'Marketplace',
            'Smart contract',
            'NewLaw/Everyone is right/Force for peace',
            'Withdrawal Rights/Disclaimer/ Privacy standards',
            'Embedded application',
            'Multi ID system',
            "If you don't rate, you can't be rated",
            'Privacy, scalability, security, transparency, decentralization, and identification',
            'Autotranslate'
        ];
        return permanentProposals.includes(name);
    }

    // Enhanced create proposal method
    async createProposal(proposal: {
        title: string;
        description: string;
        category: number;
        votingPeriod: number;
        isPermanent?: boolean;
    }): Promise<string> {
        try {
            // Create proposal in DAO system
            const tx = await this.stateConstituent.createProposal(
                proposal.title,
                proposal.description,
                proposal.category
            );
            const receipt = await tx.wait();
            
            const event = receipt.events?.find(e => e.event === 'ProposalCreated');
            const proposalId = event?.args?.proposalId.toString();

            if (!proposalId) {
                throw new Error('Failed to get proposal ID from transaction');
            }

            // Create in legacy system if available
            if (this.contractService.raven) {
                const legacyProposal: LegacyProposalInput = {
                    name: proposal.title,
                    about: JSON.stringify({
                        problem: proposal.description,
                        proposalID: proposalId,
                        solution: '',
                        targetAudience: '',
                        qualifications: '',
                        purpose: proposal.description,
                        approach: '',
                        outcome: '',
                        timeline: proposal.isPermanent ? 'Permanent' : `${proposal.votingPeriod} days`,
                        budget: '',
                        callToAction: '',
                        voting: [],
                        category: proposal.category
                    }),
                    picture: '',
                    isPermanent: proposal.isPermanent
                };

                await this.contractService.raven.createChannel(legacyProposal);
            }

            return proposalId;

        } catch (error) {
            console.error('Error creating proposal:', error);
            throw error;
        }
    }

  async castVote(
    proposalId: string,
    support: boolean,
    votingPower: BigNumber
  ): Promise<void> {
    try {
      // Cast vote in DAO system
      await this.stateConstituent.castVote(proposalId, support);

      // Cast vote in legacy system if available
      if (this.contractService.raven) {
        const channel = await this.contractService.raven.findChannel(proposalId);
        if (channel) {
          await this.contractService.raven.sendDirectMessage(
            channel.id,
            support ? 'VOTE_FOR' : 'VOTE_AGAINST'
          );
        }
      }
    } catch (error) {
      console.error('Error casting vote:', error);
      throw error;
    }
  }

  async getProposalVotes(proposalId: string): Promise<{
    forVotes: BigNumber;
    againstVotes: BigNumber;
  }> {
    try {
      // Get votes from both systems in parallel
      const [onChainProposal, legacyVotes] = await Promise.all([
        this.stateConstituent.getProposal(proposalId)
          .catch(() => ({ 
            forVotes: BigNumber.from(0), 
            againstVotes: BigNumber.from(0) 
          })),
        this.getLegacyVotes(proposalId)
      ]);

      return {
        forVotes: onChainProposal.forVotes.add(legacyVotes.forVotes),
        againstVotes: onChainProposal.againstVotes.add(legacyVotes.againstVotes)
      };
    } catch (error) {
      console.error('Error getting proposal votes:', error);
      return {
        forVotes: BigNumber.from(0),
        againstVotes: BigNumber.from(0)
      };
    }
  }

  private async getLegacyVotes(proposalId: string): Promise<{
    forVotes: BigNumber;
    againstVotes: BigNumber;
  }> {
    if (!this.contractService.raven) {
      return {
        forVotes: BigNumber.from(0),
        againstVotes: BigNumber.from(0)
      };
    }

    try {
      const messages = await this.contractService.raven.getChannelMessages(proposalId);
      
      let forVotes = BigNumber.from(0);
      let againstVotes = BigNumber.from(0);

      messages.forEach((msg: Message) => {
        if (msg.content === 'VOTE_FOR') {
          forVotes = forVotes.add(1);
        } else if (msg.content === 'VOTE_AGAINST') {
          againstVotes = againstVotes.add(1);
        }
      });

      return { forVotes, againstVotes };
    } catch (error) {
      console.error('Error getting legacy votes:', error);
      return {
        forVotes: BigNumber.from(0),
        againstVotes: BigNumber.from(0)
      };
    }
  }
}
=== ./NetworkProfile.tsx ===
// Main App: src/views/components/dashboard/VotingInterface.tsx
import React, { useState, useEffect } from 'react';
import { ContractService } from './contractService';
import { ethers } from 'ethers';
import { useWeb3Manager } from 'hooks/useWeb3Manager';
import { AuthorityService, VotingCapabilityType, AuthorityStateResponse } from 'services/AuthorityService';
import { ProposalState as ProposalLifecycleState } from 'services/ProposalLifecycle';

import {
  Card,
  CardContent,
  CardHeader,
  Typography,
  Button,
  LinearProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  Box,
  TextField,
  CircularProgress,
  Chip
} from '@mui/material';

import { Loader2, ThumbsUp, ThumbsDown, Timer, Users } from 'lucide-react';

// Define interface for component props
interface VotingInterfaceProps {
  proposal: {
    id: string;
    title: string;
    description: string;
    proposer?: string;
    startTime?: number;
    endTime?: number;
    forVotes?: ethers.BigNumber;
    againstVotes?: ethers.BigNumber;
    executed?: boolean;
    category?: number;
  };
}

// Define interface for proposal state
interface ProposalStateData {
  state: number;
  endEpoch: number;
  forVotes: ethers.BigNumber;
  againstVotes: ethers.BigNumber;
}

// Enum for proposal states
const ProposalState = {
  Pending: 0,
  Active: 1,
  Canceled: 2,
  Defeated: 3,
  Succeeded: 4,
  Executed: 5
} as const;

type ProposalStateType = typeof ProposalState[keyof typeof ProposalState];

const formatCapability = (key: string): string => {
  switch (key) {
    case 'daoStructure': return 'DAO Structure';
    case 'complexGovernance': return 'Complex Governance';
    case 'sovereignAuthority': return 'Sovereign Authority';
    default: return key;
  }
};

const VotingInterface: React.FC<VotingInterfaceProps> = ({ proposal }) => {
  const [loading, setLoading] = useState<boolean>(false);
  const [proposalState, setProposalState] = useState<ProposalStateData | null>(null);
  const [timeRemaining, setTimeRemaining] = useState<string>('');
  const [voteAmount, setVoteAmount] = useState<string>('');
  const [voteForDialogOpen, setVoteForDialogOpen] = useState<boolean>(false);
  const [voteAgainstDialogOpen, setVoteAgainstDialogOpen] = useState<boolean>(false);
  const [contractService, setContractService] = useState<ContractService | null>(null);
  const [authorityState, setAuthorityState] = useState<AuthorityStateResponse | null>(null);
  
useEffect(() => {
  if (!contractService) {
    console.error("[VotingInterface] Contract service not initialized.");
  }

  if (!!contractService) {
    console.error("[VotingInterface] Contract service initialized.");
  }
}, []);
  
  const { web3State } = useWeb3Manager();

  // Initialize contract service
  useEffect(() => {
    const initializeContract = async (): Promise<void> => {
    try {
        if (!window.ethereum) {
            throw new Error('Web3 provider not found');
        }
        
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []); // Ensure we have permission
        
        const signer = provider.getSigner();
        const address = await signer.getAddress();
        
        console.log('Connected with address:', address);
        
        const service = new ContractService(
            provider,
            '0x23767A0C9A072C6A081C27A1C03Cc95B9F9cc6E0'
        );
        
        // Verify contract connection
        const testCall = await service.contract.provider;
        if (!testCall) {
            throw new Error('Contract connection failed');
        }
        
        setContractService(service);
        
        // Fetch initial proposal state
        if (proposal.id) {
            const state = await service.getProposalState(parseInt(proposal.id));
            setProposalState(state);
        }
    } catch (error) {
        console.error('Error initializing contract:', error);
        // Show user-friendly error message
        //setError('Failed to connect to blockchain. Please check your wallet connection.');
    }
};

    initializeContract();
  }, [proposal.id]);

  // Update time remaining
  useEffect(() => {
    const updateTimeRemaining = (): void => {
      if (!proposalState) return;

      const now = Math.floor(Date.now() / 1000);
      const end = proposalState.endEpoch;
      const diff = end - now;

      if (diff <= 0) {
        setTimeRemaining('Voting ended');
        return;
      }

      const days = Math.floor(diff / (24 * 60 * 60));
      const hours = Math.floor((diff % (24 * 60 * 60)) / (60 * 60));
      const minutes = Math.floor((diff % (60 * 60)) / 60);

      setTimeRemaining(`${days}d ${hours}h ${minutes}m remaining`);
    };

    updateTimeRemaining();
    const interval = setInterval(updateTimeRemaining, 60000);
    return () => clearInterval(interval);
  }, [proposalState]);

  useEffect(() => {
    const loadAuthorityState = async (): Promise<void> => {
      if (!contractService || !web3State.account) return;
      
      try {
        const authorityService = AuthorityService.getInstance(contractService);
        const state = await authorityService.getCurrentState(web3State.account);
        setAuthorityState(state);
      } catch (error) {
        console.error('Error loading authority state:', error);
      }
    };

    loadAuthorityState();
  }, [contractService, web3State.account]);
  
  const closeVoteDialogs = (): void => {
    setVoteForDialogOpen(false);
    setVoteAgainstDialogOpen(false);
    setVoteAmount('');
  };

  const handleVote = async (support: boolean): Promise<void> => {
    if (!contractService || !voteAmount || !authorityState) return;

    setLoading(true);
    try {
      const authorityService = AuthorityService.getInstance(contractService);
      const baseAmount = ethers.utils.parseEther(voteAmount);
      
      // Calculate weighted voting power
      const votingPower = await authorityService.getVotingPower(
        web3State.account || '',
        BigInt(baseAmount.toString())
      );

      // Check for veto capability on against votes
      if (!support && await authorityService.hasCapability(
        web3State.account || '',
        VotingCapabilityType.VETO_VOTE
      )) {
        await handleVetoVote(votingPower);
        return;
      }

      await contractService.castVote(parseInt(proposal.id), support, ethers.BigNumber.from(votingPower.toString()));
      
      // Update state after voting
      const newState = await contractService.getProposalState(parseInt(proposal.id));
      setProposalState(newState);
      
      closeVoteDialogs();
    } catch (error) {
      console.error('Error casting vote:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleVetoVote = async (votingPower: bigint): Promise<void> => {
    // Implementation for veto vote handling
    // Add your veto vote logic here
  };

  const hasCapability = (capability: VotingCapabilityType): boolean => {
    return authorityState?.capabilities.includes(capability) || false;
  };

  // Add authority-specific UI elements
  const renderAuthorityIndicators = (): React.ReactNode => {
    if (!authorityState) return null;

    return (
      <Box sx={{ mt: 2, display: 'flex', gap: 1 }}>
        {Object.values(VotingCapabilityType).map((capability) => (
          <Chip
            key={capability}
            label={formatCapability(capability)}
            color={hasCapability(capability) ? 'primary' : 'default'}
            size="small"
          />
        ))}
      </Box>
    );
  };

  if (!proposalState) {
    return (
      <Card>
        <CardContent>
          <Box display="flex" justifyContent="center" p={3}>
            <CircularProgress />
          </Box>
        </CardContent>
      </Card>
    );
  }

  const totalVotes = proposalState.forVotes.add(proposalState.againstVotes);
  const forPercentage = totalVotes.gt(0)
    ? proposalState.forVotes.mul(100).div(totalVotes).toNumber()
    : 0;
  const againstPercentage = 100 - forPercentage;

  const isVotingActive = proposalState.state === ProposalState.Active;

  return (
    <Card>
      <CardHeader
        title={
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
            <Typography variant="h6">
              {proposal.title}
              <Typography
                component="span"
                variant="subtitle2"
                sx={{ ml: 1, color: 'text.secondary' }}
              >
                #{proposal.id}
              </Typography>
            </Typography>
          </Box>
        }
        subheader={
          <Box sx={{ mt: 1 }}>
            <Typography variant="body2" color="text.secondary">
              {proposal.description}
            </Typography>
            <Box sx={{ 
              display: 'flex', 
              alignItems: 'center', 
              gap: 2, 
              mt: 1,
              color: 'text.secondary'
            }}>
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <Box sx={{ mr: 1 }}>
                <Timer size={16} />
              </Box>
              {timeRemaining}
            </Box>
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <Box sx={{ mr: 1 }}>
                <Users size={16} />
              </Box>
              {totalVotes.toString()} votes
            </Box>
            </Box>
          </Box>
        }
        action={renderAuthorityIndicators()}
      />

      <CardContent>
        {/* Voting Progress */}
        <Box sx={{ mb: 4 }}>
          {/* For Votes */}
          <Box sx={{ mb: 2 }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
              <Typography variant="body2">For</Typography>
              <Typography variant="body2">{forPercentage}%</Typography>
            </Box>
            <LinearProgress 
              variant="determinate" 
              value={forPercentage}
              sx={{
                height: 8,
                backgroundColor: 'error.light',
                '& .MuiLinearProgress-bar': {
                  backgroundColor: 'success.main'
                }
              }}
            />
            <Typography variant="body2" color="text.secondary" sx={{ mt: 0.5 }}>
              {ethers.utils.formatEther(proposalState.forVotes)} votes
            </Typography>
          </Box>

          {/* Against Votes */}
          <Box sx={{ mb: 2 }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
              <Typography variant="body2">Against</Typography>
              <Typography variant="body2">{againstPercentage}%</Typography>
            </Box>
            <LinearProgress 
              variant="determinate" 
              value={againstPercentage}
              sx={{
                height: 8,
                backgroundColor: 'success.light',
                '& .MuiLinearProgress-bar': {
                  backgroundColor: 'error.main'
                }
              }}
            />
            <Typography variant="body2" color="text.secondary" sx={{ mt: 0.5 }}>
              {ethers.utils.formatEther(proposalState.againstVotes)} votes
            </Typography>
          </Box>
        </Box>

        {/* Voting Actions */}
        <Box sx={{ 
          display: 'flex', 
          justifyContent: 'space-between', 
          mt: 2 
        }}>
          {isVotingActive && (
            <>
              <Button
                variant="outlined"
                color="error"
                onClick={() => setVoteAgainstDialogOpen(true)}
                disabled={loading}
                startIcon={<ThumbsDown />}
                sx={{ flex: 1, mr: 1 }}
              >
                Vote Against
              </Button>
              <Button
                variant="contained"
                color="success"
                onClick={() => setVoteForDialogOpen(true)}
                disabled={loading}
                startIcon={<ThumbsUp />}
                sx={{ flex: 1, ml: 1 }}
              >
                Vote For
              </Button>
            </>
          )}
        </Box>

        {/* Vote For Dialog */}
        <Dialog 
          open={voteForDialogOpen} 
          onClose={() => setVoteForDialogOpen(false)}
        >
          <DialogTitle>Cast Vote For Proposal</DialogTitle>
          <DialogContent>
            <DialogContentText sx={{ mb: 2 }}>
              Enter the amount of tokens you want to vote with:
            </DialogContentText>
            <TextField
              label="Vote Amount"
              type="number"
              value={voteAmount}
              onChange={(e) => setVoteAmount(e.target.value)}
              fullWidth
              sx={{ mb: 2 }}
            />
            <DialogContentText color="warning.main">
              This action cannot be undone.
            </DialogContentText>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setVoteForDialogOpen(false)}>Cancel</Button>
            <Button
              onClick={() => handleVote(true)}
              variant="contained"
              color="success"
              disabled={loading || !voteAmount}
            >
              {loading ? <Loader2 className="animate-spin" /> : 'Confirm Vote'}
            </Button>
          </DialogActions>
        </Dialog>

        {/* Vote Against Dialog */}
        <Dialog 
          open={voteAgainstDialogOpen} 
          onClose={() => setVoteAgainstDialogOpen(false)}
        >
          <DialogTitle>Cast Vote Against Proposal</DialogTitle>
          <DialogContent>
            <DialogContentText sx={{ mb: 2 }}>
              Enter the amount of tokens you want to vote with:
            </DialogContentText>
            <TextField
              label="Vote Amount"
              type="number"
              value={voteAmount}
              onChange={(e) => setVoteAmount(e.target.value)}
              fullWidth
              sx={{ mb: 2 }}
            />
            <DialogContentText color="warning.main">
              This action cannot be undone.
            </DialogContentText>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setVoteAgainstDialogOpen(false)}>Cancel</Button>
            <Button
              onClick={() => handleVote(false)}
              variant="contained"
              color="error"
              disabled={loading || !voteAmount}
            >
              {loading ? <Loader2 className="animate-spin" /> : 'Confirm Vote'}
            </Button>
          </DialogActions>
        </Dialog>
      </CardContent>
    </Card>
  );
};

export default VotingInterface;
=== ./index.tsx ===
// Main App: src/views/components/dashboard/index.tsx
import React from 'react';
import { Box, Typography, Button } from '@mui/material';
import { Channel, Message } from 'types';

interface DashboardProps {
  channel: Channel;
  messages: Message[];
}

const Dashboard: React.FC<DashboardProps> = ({ channel, messages }) => {
  return (
    <Box sx={{ p: 2 }}>
      <Typography variant="h4">Dashboard</Typography>
      
      {/* Committees */}
      <Box sx={{ mb: 4 }}>
        <Typography variant="h5">Committees</Typography>
        {/* Add committee information here */}
      </Box>

      {/* Proposal Details */}
      <Box sx={{ mb: 4 }}>
        <Typography variant="h5">Proposal Details</Typography>
        <Typography>Name: {channel.name}</Typography>
        <Typography>Creator: {channel.creator}</Typography>
        {/* Add more proposal details here */}
      </Box>

      {/* Activities */}
      <Box sx={{ mb: 4 }}>
        <Typography variant="h5">Activities</Typography>
        {messages.slice(0, 5).map((message) => (
          <Box key={message.id} sx={{ mb: 1 }}>
            <Typography>Contributor: {message.creator}</Typography>
            <Typography>Message: {message.content}</Typography>
          </Box>
        ))}
      </Box>

      {/* Rewards */}
      <Box>
        <Typography variant="h5">Rewards</Typography>
        <Typography>Reward distribution to be implemented</Typography>
      </Box>
    </Box>
  );
};

export default Dashboard;
=== ./LegalProgressionSystem.tsx ===
// Main App: src/views/components/dashboard/LegalProgressionSystem.tsx
import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Card, 
  CardContent,
  Typography,
  LinearProgress,
  Grid,
  Chip,
  Button,
  Alert
} from '@mui/material';
import AccountBalanceIcon from '@mui/icons-material/AccountBalance';
import SecurityIcon from '@mui/icons-material/Security';
import GavelIcon from '@mui/icons-material/Gavel';
import { useWeb3Manager } from '../../../hooks/useWeb3Manager';

// Import existing components
import TokenMetrics from './TokenMetrics';
import UnifiedFieldsSystem from './UnifiedFieldsSystem';

interface LegalState {
  level: number;
  currentState: string;
  capabilities: string[];
  nextStateRequirements: Requirement[];
}

interface Requirement {
  type: string;
  threshold: number;
  current: number;
  description?: string;
  achieved?: boolean;
}

// Define legal state names and their corresponding levels
const LEGAL_STATES = {
  INITIAL: { level: 0, name: 'Initial State' },
  BASIC: { level: 16.67, name: 'Basic Legal Framework' },
  INTERMEDIATE: { level: 33.33, name: 'Intermediate Framework' },
  ADVANCED: { level: 50.00, name: 'Advanced Framework' },
  UNIFIED: { level: 66.67, name: 'Unified Legal System' },
  COMPLETE: { level: 83.33, name: 'Complete Legal Framework' }
} as const;

// Helper function to get legal state name based on level
const getLegalStateName = (level: number): string => {
  const states = Object.values(LEGAL_STATES);
  const currentState = states.reduce((prev, curr) => {
    return (level >= curr.level && curr.level > prev.level) ? curr : prev;
  }, states[0]);
  return currentState.name;
};

// Helper function to map capabilities based on level
const mapCapabilities = (level: number): string[] => {
  const capabilities: string[] = [];
  
  if (level >= LEGAL_STATES.BASIC.level) {
    capabilities.push('Basic Legal Operations');
  }
  if (level >= LEGAL_STATES.INTERMEDIATE.level) {
    capabilities.push('Advanced Governance');
  }
  if (level >= LEGAL_STATES.ADVANCED.level) {
    capabilities.push('Automated Compliance');
  }
  if (level >= LEGAL_STATES.UNIFIED.level) {
    capabilities.push('Cross-Chain Integration');
  }
  if (level >= LEGAL_STATES.COMPLETE.level) {
    capabilities.push('Full Legal Autonomy');
  }
  
  return capabilities;
};

// Helper function to get requirements for next state
const getNextStateRequirements = (level: number): Requirement[] => {
  const states = Object.values(LEGAL_STATES);
  const nextState = states.find(state => state.level > level);
  
  if (!nextState) {
    return [];
  }

  return [
    {
      type: 'Governance Participation',
      threshold: 1000,
      current: 750,
      description: 'Active governance participants required',
      achieved: false
    },
    {
      type: 'Proposal Success Rate',
      threshold: 75,
      current: 65,
      description: 'Percentage of successful proposals',
      achieved: false
    },
    {
      type: 'Community Engagement',
      threshold: 5000,
      current: 4200,
      description: 'Total number of active community members',
      achieved: false
    }
  ];
};

// Helper function to check if progression is possible
const canProgress = (state: LegalState | null): boolean => {
  if (!state || !state.nextStateRequirements) {
    return false;
  }
  
  return state.nextStateRequirements.every(req => req.current >= req.threshold);
};

const LegalProgressionSystem: React.FC = () => {
  const { web3State, contractService } = useWeb3Manager();
  const [legalState, setLegalState] = useState<LegalState | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadLegalState = async () => {
      if (!contractService) {
        console.warn('Contract service not initialized');
        return;
      }

      try {
        setLoading(true);
        const state = await contractService.getProposalState(0);
        
        // Map contract state to legal framework levels
        const stage = state.data.stage || 0;
        const level = stage >= 3 ? 
          16.67 + (stage - 3) * 1.85185185 : 
          16.67;

        setLegalState({
          level,
          currentState: getLegalStateName(level),
          capabilities: mapCapabilities(level),
          nextStateRequirements: getNextStateRequirements(level)
        });
      } catch (error) {
        console.error('Failed to load legal state:', error);
      } finally {
        setLoading(false);
      }
    };

    if (contractService) {
      loadLegalState();
    }
  }, [contractService]);

  // Early return for loading state
  if (loading) {
    return (
      <Box sx={{ mt: 3 }}>
        <Card>
          <CardContent>
            <LinearProgress />
          </CardContent>
        </Card>
      </Box>
    );
  }

  return (
    <Box sx={{ mt: 3 }}>
      <Card>
        <CardContent>
          <Grid container spacing={3}>
            {/* Legal Framework Status */}
            <Grid item xs={12} md={6}>
              <Box sx={{ mb: 2 }}>
                <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  <AccountBalanceIcon />
                  Legal Framework Status
                </Typography>
                <Typography variant="body2" color="textSecondary">
                  Current Level: {legalState?.level.toFixed(8)}
                </Typography>
              </Box>

              <Box sx={{ mb: 3 }}>
                <Typography variant="body2" color="textSecondary" gutterBottom>
                  Progress to Next State
                </Typography>
                <LinearProgress 
                  variant="determinate" 
                  value={((legalState?.level || 0) % 1.85185185) * 100} 
                  sx={{ height: 8, borderRadius: 1 }}
                />
              </Box>

              <Box sx={{ mb: 2 }}>
                <Typography variant="subtitle2" gutterBottom>
                  Active Capabilities
                </Typography>
                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                  {legalState?.capabilities.map((cap, index) => (
                    <Chip 
                      key={index}
                      label={cap}
                      icon={<SecurityIcon />}
                      color="primary"
                      variant="outlined"
                    />
                  ))}
                </Box>
              </Box>
            </Grid>

            {/* Requirements and Progression */}
            <Grid item xs={12} md={6}>
              <Box sx={{ mb: 2 }}>
                <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  <GavelIcon />
                  Next State Requirements
                </Typography>
              </Box>

              {legalState?.nextStateRequirements.map((req, index) => (
                <Alert 
                  key={index}
                  severity={req.achieved ? "success" : "info"}
                  sx={{ mb: 1 }}
                >
                  <Typography variant="body2">
                    {req.description}
                  </Typography>
                  <LinearProgress 
                    variant="determinate"
                    value={(req.current / req.threshold) * 100}
                    sx={{ mt: 1 }}
                  />
                </Alert>
              ))}

              <Button 
                variant="contained"
                fullWidth
                disabled={!canProgress(legalState)}
                sx={{ mt: 2 }}
              >
                Progress to Next State
              </Button>
            </Grid>
          </Grid>
        </CardContent>
      </Card>

      {/* Integration with existing components */}
      <Grid container spacing={3} sx={{ mt: 2 }}>
        <Grid item xs={12} md={6}>
          <TokenMetrics />
        </Grid>
        <Grid item xs={12} md={6}>
          <UnifiedFieldsSystem />
        </Grid>
      </Grid>
    </Box>
  );
};

export default LegalProgressionSystem;
=== ./contractService.ts ===
// Main App: views/components/dashboard/contractService.ts
import { ethers, BigNumber } from 'ethers';

import StateConstituentABI from 'contracts/abis/StateConstituent.json';
import LogicConstituentABI from 'contracts/abis/LogicConstituent.json';
import ViewConstituentABI from 'contracts/abis/ViewConstituent.json';
import DAOTokenABI from 'contracts/abis/DAOToken.json';

import { 
  IStateConstituent, 
  IViewConstituent, 
  IDAOToken, 
  ILogicConstituent,
  ContractInstances as ImportedContractInstances,
  ProposalData,
  ProposalStateOld
} from 'types/contracts';


// Define our domain state types for better type safety
export enum DomainStateType {
    Initial = 'INITIAL',
    Active = 'ACTIVE',
    Mature = 'MATURE'
}

// The base ABI needed for contract interactions
const tokenAbi = [
    // DAO status functions
    "function proposalCount() external view returns (uint256)",
    "function activeUserCount() external view returns (uint256)",
    "function currentEpoch() external view returns (uint256)",
    "function lastEpochUpdate() external view returns (uint256)",
    "function currentStage() external view returns (uint256)",
    "function daoAnalytics() external view returns (uint256, uint256, uint256, uint256)",
    
    // Proposal creation and management
    "function createProposal(address proposer, uint8 category, uint256 startEpoch, uint256 endEpoch) external returns (uint256)",
    
    // Voting functionality
    "function getProposalState(uint256 proposalId) external view returns (uint8, uint256, uint256, bool, bool, uint256, uint256, uint8, uint256)",
    "function castVote(uint256 proposalId, bool support, uint256 voteAmount) external",
    "function getProposalBasicInfo(uint256 proposalId) external view returns (uint256, uint256, bool, bool, uint256, uint256, uint8, uint256)",
    
    // Member management
    "function initializeAdmin() external",
    "function registerMember(address member) external",
    "function isDaoMember(address) external view returns (bool)",
    "function activeDaoList(uint256) external view returns (address)",
    "function daoPosInList(address) external view returns (uint256)",
    
    // Token economics
    "function performAnnualMint() external",
    "function isActiveUser(address) external view returns (bool)",
    "function daoBiddingShares(address) external view returns (uint256)",
    "function lastAnnualMint() external view returns (uint256)",
    "function totalSupply() external view returns (uint256)",
    "function placeBid(uint256 amount, uint256 price, bool isPermanent) external",
    "function getDaoLimit(address) external view returns (uint256)",
    "function getTotalDaoBids(address) external view returns (uint256)",
    "function dailyAllocation() external view returns (uint256)",
    "function calculateDailyAllocation() external",
    "function recordActivity(address) external",
    "function lastActivity(address) external view returns (uint256)",
    "function currentDailyPrice() external view returns (uint256)",
    "function treasuryBalance() external view returns (uint256)",
    "function balanceOf(address) external view returns (uint256)"
];

// Define strongly-typed interfaces for our return types
export interface TokenMetrics {
    price: string;
    supply: string;
    treasuryBalance: string;
    activeUsers: number;
    dailyAllocation: string;
    fieldStrength?: number;
    fieldSynchronization?: number;
    unityProgress?: number;
}

interface ProposalState {
    state: number;
    startEpoch: number;
    endEpoch: number;
    canceled: boolean;
    executed: boolean;
    forVotes: ethers.BigNumber;
    againstVotes: ethers.BigNumber;
    stage: number;
    proposerReputation: number;
}

export interface DomainState {
  level: number;
  state: DomainStateType;  // This exists
  stage: number;           // Add this for the stage property
  capabilities: string[];
  requirements: Requirement[];
  nextState?: DomainStateType;
  governanceWeight: number;
  lastStateUpdate: number;  // Add this to match component usage
}

interface FieldMetrics {
    fieldStrength: number;
    fieldSynchronization: number;
    unityProgress: number;
}

interface Requirement {
    type: string;
    threshold: number;
    current: number;
    description?: string;
    achieved?: boolean;
}

// Add this interface to ContractService.ts
export interface FoundationMetrics {
    tokenMetrics: TokenMetrics;
    fieldMetrics: FieldMetrics;
    balance: ethers.BigNumber;
    activityScore: number;
}

export interface StateContractFunctions {
    proposals(id: number): Promise<any>;
    proposalStage(id: number): Promise<number>;
    // ... other state functions
}

export interface DAOTokenFunctions {
    currentDailyPrice(): Promise<ethers.BigNumber>;
    totalSupply(): Promise<ethers.BigNumber>;
    treasuryBalance(): Promise<ethers.BigNumber>;
    activeUserCount(): Promise<ethers.BigNumber>;
    dailyAllocation(): Promise<ethers.BigNumber>;
    // ... other token functions
}

interface ContractInstances {
    stateConstituent: ethers.Contract & StateContractFunctions;
    daoToken: ethers.Contract & DAOTokenFunctions;
    logicConstituent: ethers.Contract;
    viewConstituent?: ethers.Contract & IViewConstituent; // Make it optional since we don't always need it
}

// In contractService.ts
export interface StateContractFunctions {
    proposals(id: number): Promise<any>;
    proposalStage(id: number): Promise<number>;
    // ... other state functions
}

export interface DAOTokenFunctions {
    currentDailyPrice(): Promise<ethers.BigNumber>;
    totalSupply(): Promise<ethers.BigNumber>;
    treasuryBalance(): Promise<ethers.BigNumber>;
    activeUserCount(): Promise<ethers.BigNumber>;
    dailyAllocation(): Promise<ethers.BigNumber>;
    // ... other token functions
}

// The main ContractService class implementation
/*export class ContractService {
    private readonly provider: ethers.providers.Web3Provider;
    public contract: ethers.Contract; // removed readonly- is redefined later
    private readonly contractAddress: string;
    public readonly stateContract: ethers.Contract;
    public readonly logicContract: ethers.Contract;
    public readonly logicConstituent: ethers.Contract;
    public readonly daoToken: ethers.Contract;*/

// Define a local interface that combines ethers.Contract with our specific interfaces
interface StronglyTypedContracts {
    stateConstituent: ethers.Contract & StateContractFunctions & IStateConstituent;
    daoToken: ethers.Contract & DAOTokenFunctions & IDAOToken;
    logicConstituent: ethers.Contract & ILogicConstituent;
    viewConstituent: ethers.Contract & IViewConstituent;
}

// Enhanced interfaces for the Raven service integration
interface RavenMessage {
    id: string;
    content: string;
    timestamp: number;
    type: 'VOTE_FOR' | 'VOTE_AGAINST' | 'COMMENT';
}

interface RavenProposal {
    id: string;
    content: string;
    created_at: number;
    category?: number;
    isPermanent?: boolean;
}

interface RavenService {
    fetchAllProposal(): Promise<RavenProposal[]>;
    createChannel(proposal: any): Promise<any>;
    findChannel(id: string): Promise<any>;
    sendDirectMessage(channelId: string, content: string): Promise<void>;
    getChannelMessages(channelId: string): Promise<RavenMessage[]>;
    updateReadMarkMap(map: Record<string, number>): Promise<void>;
}

export class ContractService {
    private readonly provider: ethers.providers.Web3Provider;
    public stateContract: ethers.Contract & StateContractFunctions & IStateConstituent;
    public daoToken: ethers.Contract & DAOTokenFunctions & IDAOToken;
    public contract: ethers.Contract;
    private readonly contractAddress: string;
    public readonly logicContract: ethers.Contract & ILogicConstituent;
    public readonly logicConstituent: ethers.Contract & ILogicConstituent;
    public readonly viewContract: ethers.Contract & IViewConstituent;
    public readonly contracts: {
        stateConstituent: ethers.Contract & IStateConstituent;
        daoToken: ethers.Contract & IDAOToken;
        logicConstituent: ethers.Contract & ILogicConstituent;
        viewConstituent?: ethers.Contract & IViewConstituent;
    };
    public readonly raven?: RavenService;

constructor(provider: ethers.providers.Web3Provider, contractAddress: string, ravenService?: RavenService) {
    this.provider = provider;
    this.raven = ravenService;
    this.contractAddress = contractAddress;
    
    const signer = provider.getSigner();
        
        // Initialize with proper type assertions
        this.stateContract = new ethers.Contract(
            "0x473b40c989A259eAcED8D8829A1517692aEa8c82",
            StateConstituentABI,
            signer
        ) as ethers.Contract & StateContractFunctions & IStateConstituent;
        
        this.daoToken = new ethers.Contract(
            "0x23767A0C9A072C6A081C27A1C03Cc95B9F9cc6E0",
            DAOTokenABI,
            signer
        ) as ethers.Contract & DAOTokenFunctions & IDAOToken;
        
        this.logicContract = new ethers.Contract(
            "0x4F10e042C775F5F821339D89d2a5656c7B4C49ba",
            LogicConstituentABI,
            signer
        ) as ethers.Contract & ILogicConstituent;
        
        this.viewContract = new ethers.Contract(
            "0x658D387603B5758336a13b79276Ddd580642121C",
            ViewConstituentABI,
            signer
        ) as ethers.Contract & IViewConstituent;

        this.logicConstituent = this.logicContract;
        
        // Initialize contracts with proper types
        this.contracts = {
            stateConstituent: new ethers.Contract(
                "0x473b40c989A259eAcED8D8829A1517692aEa8c82",
                StateConstituentABI,
                signer
            ) as ethers.Contract & IStateConstituent,

            daoToken: new ethers.Contract(
                "0x23767A0C9A072C6A081C27A1C03Cc95B9F9cc6E0",
                DAOTokenABI,
                signer
            ) as ethers.Contract & IDAOToken,

            logicConstituent: new ethers.Contract(
                "0x4F10e042C775F5F821339D89d2a5656c7B4C49ba",
                LogicConstituentABI,
                signer
            ) as ethers.Contract & ILogicConstituent,

            viewConstituent: new ethers.Contract(
                "0x658D387603B5758336a13b79276Ddd580642121C",
                ViewConstituentABI,
                signer
            ) as ethers.Contract & IViewConstituent
        };
        
        // Verify contract initialization
        if (!this.verifyContracts()) {
            throw new Error('Contract initialization failed');
        }
        
        this.contract = this.stateContract;
    }

    private verifyContracts(): boolean {
        return !!(
            this.contracts.stateConstituent.provider &&
            this.contracts.daoToken.provider &&
            this.contracts.logicConstituent.provider
        );
    }

    // Field calculation methods
    private calculateFieldStrength(totalSupply: ethers.BigNumber, dailyAllocation: ethers.BigNumber): number {
        const supplyNumber = parseFloat(ethers.utils.formatEther(totalSupply));
        const allocationNumber = parseFloat(ethers.utils.formatEther(dailyAllocation));
        return (allocationNumber / supplyNumber) * 100;
    }

    private calculateSynchronization(dailyAllocation: ethers.BigNumber): number {
        const allocationNumber = parseFloat(ethers.utils.formatEther(dailyAllocation));
        return Math.min(allocationNumber * 2, 100); // Example calculation
    }

    private calculateUnityProgress(activeUsers: number): number {
        const targetUsers = 10000; // Example target
        return Math.min((activeUsers / targetUsers) * 100, 100);
    }

    // Metric gathering methods
    async getActivityMetrics(address: string): Promise<number> {
        const activity = await this.contract.getActivityCount(address);
        return activity.toNumber();
    }

    async getParticipationMetrics(address: string): Promise<number> {
        const participation = await this.contract.getParticipationScore(address);
        return participation.toNumber();
    }

    async getContributionMetrics(address: string): Promise<number> {
        const contribution = await this.contract.getContributionScore(address);
        return contribution.toNumber();
    }

    async getReputationScore(address: string): Promise<number> {
        const reputation = await this.contract.getReputationScore(address);
        return reputation.toNumber();
    }

    // State management methods
    async getState(address: string): Promise<{ level: number }> {
        const state = await this.contract.getState(address);
        return { level: state.toNumber() };
    }

    async updateState(address: string, level: string): Promise<ethers.ContractTransaction> {
        return await this.contract.updateState(address, level);
    }

// Update the getFieldState method to use the new getDomainState
async getFieldState(): Promise<{ level: number; capabilities: string[] }> {
    try {
        const domainState = await this.getDomainState();
        const capabilities = await this.logicConstituent.getDomainCapabilities(
            Math.floor(domainState.level)
        );
        return { 
            level: domainState.level,
            capabilities 
        };
    } catch (error) {
        console.error('Error getting field state:', error);
        throw error;
    }
}

    async getFieldMetrics(): Promise<FieldMetrics> {
        const [totalSupply, dailyAllocation, activeUsers] = await Promise.all([
            this.daoToken.totalSupply(),
            this.daoToken.dailyAllocation(),
            this.daoToken.activeUserCount()
        ]);
        
        return {
            fieldStrength: this.calculateFieldStrength(totalSupply, dailyAllocation),
            fieldSynchronization: this.calculateSynchronization(dailyAllocation),
            unityProgress: this.calculateUnityProgress(activeUsers.toNumber())
        };
    }

// Add this method to ContractService class
async getMetrics(address: string): Promise<FoundationMetrics> {
    try {
        // Get all metrics in parallel for better performance
        const [
            tokenMetrics,
            fieldMetrics,
            balance,
            activityScore
        ] = await Promise.all([
            this.getTokenMetrics(),
            this.getFieldMetrics(),
            this.getBalance(address),
            this.getActivityScore(address)
        ]);

        return {
            tokenMetrics,
            fieldMetrics,
            balance,
            activityScore
        };
    } catch (error) {
        console.error('Error getting foundation metrics:', error);
        throw error;
    }
}

    // DAO status methods
    async validateStateRequirements(address: string, level: number): Promise<boolean> {
        try {
            const [
                balanceReq,
                activityReq,
                reputationReq
            ] = await Promise.all([
                this.validateBalanceRequirement(address, level),
                this.validateActivityRequirement(address, level),
                this.validateReputationRequirement(address, level)
            ]);

            return balanceReq && activityReq && reputationReq;
        } catch (error) {
            console.error('Error validating state requirements:', error);
            throw error;
        }
    }

    private async validateBalanceRequirement(address: string, level: number): Promise<boolean> {
        const balance = await this.getBalance(address);
        const requirement = this.getRequiredBalance(level);
        return balance.gte(requirement);
    }

    private async validateActivityRequirement(address: string, level: number): Promise<boolean> {
        const activity = await this.getActivityScore(address);
        const requirement = this.getRequiredActivity(level);
        return activity >= requirement;
    }

    private async validateReputationRequirement(address: string, level: number): Promise<boolean> {
        const reputation = await this.getReputationScore(address);
        const requirement = this.getRequiredReputation(level);
        return reputation >= requirement;
    }

    private getRequiredBalance(level: number): ethers.BigNumber {
        // Implement balance requirements by level
        return ethers.utils.parseEther('1');
    }

    private getRequiredActivity(level: number): number {
        // Implement activity requirements by level
        return 100;
    }

    private getRequiredReputation(level: number): number {
        // Implement reputation requirements by level
        return 50;
    }

async getDAOStatus(): Promise<{
    proposalCount: number;
    activeUserCount: number;
    treasury: ethers.BigNumber;
    currentEpoch: number;
    lastEpochUpdate: number;
    currentStage: number;
    analytics: {
        transactions: number;
        users: number;
        votes: number;
        velocity: number;
    };
}> {
    try {
        const [
            proposalCount,
            activeUserCount,
            treasury,
            currentEpoch,
            lastEpochUpdate,
            currentStage,
            analyticsData
        ] = await Promise.all([
            this.contract.proposalCount(),
            this.daoToken.activeUserCount(),
            this.daoToken.treasuryBalance(),
            this.contract.currentEpoch(),
            this.contract.lastEpochUpdate(),
            this.contract.currentStage(),
            this.contract.daoAnalytics()
        ]);

        // Since daoAnalytics only returns activeUsers, we'll use that for the users metric
        // and set other analytics values to 0 for now
        return {
            proposalCount: proposalCount.toNumber(),
            activeUserCount: activeUserCount.toNumber(),
            treasury,
            currentEpoch: currentEpoch.toNumber(),
            lastEpochUpdate: lastEpochUpdate.toNumber(),
            currentStage: currentStage.toNumber(),
            analytics: {
                transactions: 0,
                users: analyticsData.toNumber(), // Use the activeUsers value
                votes: 0,
                velocity: 0
            }
        };
    } catch (error) {
        console.error('Error getting DAO status:', error);
        return {
            proposalCount: 0,
            activeUserCount: 0,
            treasury: ethers.BigNumber.from(0),
            currentEpoch: 0,
            lastEpochUpdate: Math.floor(Date.now() / 1000),
            currentStage: 0,
            analytics: {
                transactions: 0,
                users: 0,
                votes: 0,
                velocity: 0
            }
        };
    }
}

// Add this method to the ContractService class
async getDomainState(): Promise<DomainState> {
    try {
        // Get data from state contract
        const [
            daoAnalytics
        ] = await Promise.all([
            this.stateContract.daoAnalytics()
        ]);
        
        const activeUserCount = await this.daoToken.activeUserCount();

        // Calculate level using contract's formula
        const currentStage = await this.stateContract.currentStage();
        const level = 16.67 + (currentStage * 1.85185185);

        const stageNumber = currentStage.toNumber();
        
        // Calculate capabilities based on actual stage progression
        const capabilities = [];
        if (stageNumber >= 1) capabilities.push('DAO_STRUCTURE');
        if (stageNumber >= 2) capabilities.push('COMPLEX_GOVERNANCE');
        if (stageNumber >= 3) capabilities.push('SOVEREIGN_AUTHORITY');

        // Map state based on actual thresholds
        let state = DomainStateType.Initial;
        if (stageNumber >= 2) state = DomainStateType.Active;
        if (stageNumber >= 4) state = DomainStateType.Mature;

        return {
            level,
            state,
            stage: stageNumber,
            capabilities,
            requirements: [{
                type: 'STAGE',
                threshold: stageNumber + 1,
                current: stageNumber,
                description: 'Current stage progress',
                achieved: false
            }],
            nextState: this.calculateNextState(state),
            governanceWeight: Math.pow(2, stageNumber),
            lastStateUpdate: Math.floor(Date.now() / 1000)
        };
    } catch (error) {
        console.error('Failed to get domain state:', error);
        return {
            level: 16.67,
            state: DomainStateType.Initial,
            stage: 0,
            capabilities: [],
            requirements: [],
            nextState: DomainStateType.Active,
            governanceWeight: 1,
            lastStateUpdate: Math.floor(Date.now() / 1000)
        };
    }
}

// Support method for getDomainState
private calculateNextState(currentState: DomainStateType): DomainStateType | undefined {
    const states = Object.values(DomainStateType);
    const currentIndex = states.indexOf(currentState);
    return currentIndex < states.length - 1 ? states[currentIndex + 1] : undefined;
}

private async safeContractCall<T>(
    call: () => Promise<T>,
    fallback: T,
    errorContext: string,
    retries = 3
): Promise<T> {
    let lastError: Error | null = null;
    
    for (let i = 0; i < retries; i++) {
        try {
            // Ensure we have a connection before each attempt
            if (!this.contract.provider) {
                await this.reconnectProvider();
            }
            return await call();
        } catch (error) {
            lastError = error as Error;
            console.error(`Error in ${errorContext} (attempt ${i + 1}/${retries}):`, error);
            await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1))); // Exponential backoff
        }
    }
    
    console.error(`All ${retries} attempts failed for ${errorContext}:`, lastError);
    return fallback;
}

private async reconnectProvider() {
    if (window.ethereum) {
        try {
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            this.contract = new ethers.Contract(
                this.contractAddress,
                DAOTokenABI,
                signer
            );
        } catch (error) {
            console.error('Failed to reconnect provider:', error);
        }
    }
}

    // Enhanced proposal creation with Raven integration
    async createProposal(
        category: number,
        votingPeriodInDays: number,
        title: string,
        description: string,
        isPermanent: boolean = false
    ): Promise<string> {
        try {
            // Create proposal on-chain
            const currentEpoch = await this.contracts.stateConstituent.currentEpoch();
            const startEpoch = currentEpoch.add(1);
            const endEpoch = currentEpoch.add(
                isPermanent ? 365 * 24 : votingPeriodInDays * 24
            );
            
            const signer = this.provider.getSigner();
            const address = await signer.getAddress();
            
            const tx = await this.contracts.stateConstituent.createProposal(
                address,
                category,
                startEpoch,
                endEpoch
            );
            
            const receipt = await this.logTransaction(tx, 'Create Proposal');
            const event = receipt.events?.find(e => e.event === 'ProposalCreated');
            
            if (!event?.args?.proposalId) {
                throw new Error('Failed to get proposal ID from event');
            }

            const proposalId = event.args.proposalId.toString();

            // Create proposal in Raven if available
            if (this.raven) {
                const ravenProposal = {
                    name: title,
                    about: JSON.stringify({
                        problem: description,
                        proposalID: proposalId,
                        category: category,
                        timeline: isPermanent ? 'Permanent' : `${votingPeriodInDays} days`,
                        isPermanent: isPermanent
                    }),
                    picture: ''
                };

                await this.raven.createChannel(ravenProposal);
            }

            return proposalId;
        } catch (error) {
            console.error('Error creating proposal:', error);
            throw error;
        }
    }

    async getCurrentEpoch(): Promise<number> {
        try {
            const epoch = await this.contract.currentEpoch();
            return epoch.toNumber();
        } catch (error) {
            console.error('Error getting current epoch:', error);
            throw error;
        }
    }

    async getProposalCount(): Promise<number> {
        try {
            const count = await this.contract.proposalCount();
            return count.toNumber();
        } catch (error) {
            console.error('Error getting proposal count:', error);
            throw error;
        }
    }

    // Utility method for transaction logging
    private async logTransaction(
        tx: ethers.ContractTransaction,
        description: string
    ): Promise<ethers.ContractReceipt> {
        console.log(`\n📝 Transaction Details (${description}):`);
        console.log(`- Hash: ${tx.hash}`);
        console.log(`- From: ${this.formatAddress(tx.from)}`);
        console.log(`- To: ${this.formatAddress(tx.to)}`);
        
        const receipt = await tx.wait();
        console.log('\n✅ Transaction Confirmed:');
        console.log(`- Block: ${receipt.blockNumber}`);
        console.log(`- Gas Used: ${receipt.gasUsed.toString()}`);
        
        return receipt;
    }

    private formatAddress(address: string | undefined): string {
        if (!address) return 'undefined';
        return `${address.substring(0, 6)}...${address.substring(38)}`;
    }

    // Token metrics methods
    async getAuthorityMetrics(address: string): Promise<{
        level: number;
        score: number;
        lastUpdate: number;
    }> {
        try {
            const [level, score, lastUpdate] = await Promise.all([
                this.contract.getAuthorityLevel(address),
                this.contract.getAuthorityScore(address),
                this.contract.getLastUpdate(address)
            ]);

            return {
                level: level.toNumber(),
                score: score.toNumber(),
                lastUpdate: lastUpdate.toNumber()
            };
        } catch (error) {
            console.error('Error getting authority metrics:', error);
            throw error;
        }
    }

    async getBalance(address: string): Promise<ethers.BigNumber> {
        try {
            return await this.contract.balanceOf(address);
        } catch (error) {
            console.error('Error getting balance:', error);
            throw error;
        }
    }

    async getActivityScore(address: string): Promise<number> {
        try {
            const score = await this.contract.activityScore(address);
            return score.toNumber();
        } catch (error) {
            console.error('Error getting activity score:', error);
            throw error;
        }
    }

    // Now update getTokenMetrics to use the daoToken contract
    async getTokenMetrics(): Promise<TokenMetrics> {
        try {
            // Use daoToken instead of contract for token-specific operations
            const [
                currentPrice,
                totalSupply,
                treasuryBalance,
                activeUserCount,
                dailyAllocation
            ] = await Promise.all([
                this.daoToken.currentDailyPrice(),
                this.daoToken.totalSupply(),
                this.daoToken.treasuryBalance(),
                this.daoToken.activeUserCount(),
                this.daoToken.dailyAllocation()
            ]);

            // Get field metrics using the logic contract
            const fieldMetrics = await this.getFieldMetrics();

            return {
                price: ethers.utils.formatEther(currentPrice),
                supply: ethers.utils.formatEther(totalSupply),
                treasuryBalance: ethers.utils.formatEther(treasuryBalance),
                activeUsers: activeUserCount.toNumber(),
                dailyAllocation: ethers.utils.formatEther(dailyAllocation),
                ...fieldMetrics
            };
        } catch (error) {
            console.error('Error getting token metrics:', error);
            // Log more detailed error information to help with debugging
            if (error instanceof Error) {
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });
            }
            return {
                price: '0',
                supply: '0',
                treasuryBalance: '0',
                activeUsers: 0,
                dailyAllocation: '0',
                fieldStrength: 0,
                fieldSynchronization: 0,
                unityProgress: 0
            };
        }
    }

    private ensureContract(): void {
        if (!this.contract) {
            throw new Error('Contract not initialized');
        }
    }

    // Membership methods
    async getMembershipStatus(address: string): Promise<{
        isActive: boolean;
        biddingShares: number;
        lastActivity: number;
    }> {
        try {
            const [
                isActive,
                biddingShares,
                lastActivityTime
            ] = await Promise.all([
                this.contract.isActiveUser(address),
                this.contract.daoBiddingShares(address),
                this.contract.lastActivity(address)
            ]);

            return {
                isActive,
                biddingShares: biddingShares.toNumber(),
                lastActivity: lastActivityTime.toNumber()
            };
        } catch (error) {
            console.error('Error fetching membership status:', error);
            throw error;
        }
    }

    // Bidding methods
    async placeBid(amount: ethers.BigNumber, price: ethers.BigNumber, isPermanent: boolean): Promise<ethers.ContractReceipt> {
        try {
            const tx = await this.contract.placeBid(amount, price, isPermanent);
            return this.logTransaction(tx, 'Place Bid');
        } catch (error) {
            console.error('Error placing bid:', error);
            throw error;
        }
    }

    async getBidConstraints(daoAddress: string): Promise<{
        minBidAmount: ethers.BigNumber;
        maxPermanentBidAmount: ethers.BigNumber;
        availableBidRoom: ethers.BigNumber;
        daoLimit: ethers.BigNumber;
        totalBids: ethers.BigNumber;
    }> {
        try {
            const [
                dailyAllocation,
                daoLimit,
                totalBids
            ] = await Promise.all([
                this.contract.dailyAllocation(),
                this.contract.getDaoLimit(daoAddress),
                this.contract.getTotalDaoBids(daoAddress)
            ]);

            const minBidAmount = dailyAllocation.div(1000); // 0.1% minimum
            const maxPermanentBidAmount = daoLimit.mul(25).div(100); // 25% limit
            const availableBidRoom = daoLimit.sub(totalBids);

            return {
                minBidAmount,
                maxPermanentBidAmount,
                availableBidRoom,
                daoLimit,
                totalBids
            };
        } catch (error) {
            console.error('Error calculating bid constraints:', error);
            throw error;
        }
    }

    // Activity recording methods
    async recordActivity(address: string): Promise<ethers.ContractReceipt> {
        try {
            const tx = await this.contract.recordActivity(address);
            return this.logTransaction(tx, 'Record Activity');
        } catch (error) {
            console.error('Error recording activity:', error);
            throw error;
        }
    }

    async calculateDailyAllocation(): Promise<ethers.ContractReceipt> {
        try {
            const tx = await this.contract.calculateDailyAllocation();
            return this.logTransaction(tx, 'Calculate Daily Allocation');
        } catch (error) {
            console.error('Error calculating daily allocation:', error);
            throw error;
        }
    }

    // Initialization and registration methods
    async initializeAdmin(): Promise<ethers.ContractReceipt> {
        try {
            const tx = await this.contract.initializeAdmin();
            return this.logTransaction(tx, 'Initialize Admin');
        } catch (error) {
            console.error('Error initializing admin:', error);
            throw error;
        }
    }

    async registerMember(memberAddress: string): Promise<ethers.ContractReceipt> {
        try {
            const tx = await this.contract.registerMember(memberAddress);
            return this.logTransaction(tx, 'Register Member');
        } catch (error) {
            console.error('Error registering member:', error);
            throw error;
        }
    }

    // Voting methods
    // Enhanced proposal state retrieval
    async getProposalState(proposalId: number): Promise<{
        state: ProposalStateOld;
        data: ProposalData;
        ravenVotes?: {
            forVotes: number;
            againstVotes: number;
        };
    }> {
        try {
            // Get on-chain state
            const onChainState = await this.contracts.stateConstituent.getProposal(proposalId);
            
            // Get Raven votes if available
            let ravenVotes;
            if (this.raven) {
                const messages = await this.raven.getChannelMessages(proposalId.toString());
                const forVotes = messages.filter(m => m.content === 'VOTE_FOR').length;
                const againstVotes = messages.filter(m => m.content === 'VOTE_AGAINST').length;
                ravenVotes = { forVotes, againstVotes };
            }

            return {
                state: onChainState.currentState,
                data: onChainState,
                ravenVotes
            };
        } catch (error) {
            console.error('Error getting proposal state:', error);
            throw error;
        }
    }

    async castVote(
        proposalId: number,
        support: boolean,
        voteAmount: BigNumber
    ): Promise<void> {
        try {
            // Cast vote on-chain
            const tx = await this.contracts.stateConstituent.castVote(
                proposalId,
                support,
                voteAmount
            );
            await tx.wait();

            // Record vote in Raven if available
            if (this.raven) {
                await this.raven.sendDirectMessage(
                    proposalId.toString(),
                    support ? 'VOTE_FOR' : 'VOTE_AGAINST'
                );
            }
        } catch (error) {
            console.error('Error casting vote:', error);
            throw error;
        }
    }

    async getProposalBasicInfo(proposalId: number): Promise<{
        startEpoch: number;
        endEpoch: number;
        canceled: boolean;
        executed: boolean;
        forVotes: ethers.BigNumber;
        againstVotes: ethers.BigNumber;
        stage: number;
        proposerReputation: number;
    }> {
        try {
            const info = await this.contract.getProposalBasicInfo(proposalId);
            return {
                startEpoch: info[0].toNumber(),
                endEpoch: info[1].toNumber(),
                canceled: info[2],
                executed: info[3],
                forVotes: info[4],
                againstVotes: info[5],
                stage: info[6],
                proposerReputation: info[7]
            };
        } catch (error) {
            console.error('Error getting proposal info:', error);
            throw error;
        }
    }
}
=== ./TokenMetrics.tsx ===
import React, { useState, useEffect, useCallback } from 'react';
import { ethers } from 'ethers';
import {
  Card,
  CardContent,
  CardHeader,
  Typography,
  Box,
  CircularProgress,
  Alert,
} from '@mui/material';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { ContractService } from './contractService';

// Define precise types for our metrics
interface MetricsState {
  price: string;
  supply: string;
  marketCap: string;
  treasuryBalance: string;
  fieldStrength?: number;
  fieldSynchronization?: number;
  unityProgress?: number;
  priceHistory: Array<{
    timestamp: number;
    price: number;
  }>;
}

const initializeProvider = async () => {
  if (!window.ethereum) {
    throw new Error('No Web3 provider found. Please install MetaMask.');
  }
  return new ethers.providers.Web3Provider(window.ethereum);
};

const TokenMetrics = () => {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [metrics, setMetrics] = useState<MetricsState>({
    price: '0',
    supply: '0',
    marketCap: '0',
    treasuryBalance: '0',
    priceHistory: []
  });

  // Memoized format functions to prevent unnecessary re-renders
  const formatUSD = useCallback((value: string | number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(Number(value));
  }, []);

  const formatNumber = useCallback((value: string | number) => {
    return new Intl.NumberFormat('en-US').format(Number(value));
  }, []);

  const fetchMetrics = useCallback(async () => {
    try {
      setLoading(true);
      const provider = await initializeProvider();
      
      // Initialize contract service with retry logic
      const contractService = new ContractService(
        provider,
        '0x23767A0C9A072C6A081C27A1C03Cc95B9F9cc6E0'
      );

      const contractMetrics = await contractService.getTokenMetrics();
      
      // Update metrics with proper validation
      setMetrics(prev => ({
        ...prev,
        price: contractMetrics.price || '0',
        supply: contractMetrics.supply || '0',
        marketCap: (
          Number(contractMetrics.price) * 
          Number(contractMetrics.supply)
        ).toString(),
        treasuryBalance: contractMetrics.treasuryBalance || '0',
        fieldStrength: contractMetrics.fieldStrength,
        fieldSynchronization: contractMetrics.fieldSynchronization,
        unityProgress: contractMetrics.unityProgress,
        priceHistory: [
          ...prev.priceHistory,
          {
            timestamp: Date.now(),
            price: Number(contractMetrics.price)
          }
        ].slice(-24) // Keep last 24 data points
      }));
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to fetch metrics';
      console.error('Error fetching token metrics:', error);
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchMetrics();
    
    // Set up polling interval for real-time updates
    const interval = setInterval(fetchMetrics, 30000); // Update every 30 seconds
    
    return () => clearInterval(interval);
  }, [fetchMetrics]);

  if (loading) {
    return (
      <Card className="w-full">
        <CardContent>
          <Box className="flex justify-center items-center h-64">
            <CircularProgress />
          </Box>
        </CardContent>
      </Card>
    );
  }

  if (error) {
    return (
      <Card className="w-full">
        <CardContent>
          <Alert severity="error">
            {error}
          </Alert>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="w-full">
      <CardHeader title="Token Metrics" />
      <CardContent>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {/* Basic Metrics */}
          <div className="space-y-4">
            <div>
              <Typography variant="subtitle2" color="text.secondary">
                Current Price
              </Typography>
              <Typography variant="h4">
                {formatUSD(metrics.price)}
              </Typography>
            </div>
            
            <div>
              <Typography variant="subtitle2" color="text.secondary">
                Market Cap
              </Typography>
              <Typography variant="h6">
                {formatUSD(metrics.marketCap)}
              </Typography>
            </div>

            <div>
              <Typography variant="subtitle2" color="text.secondary">
                Total Supply
              </Typography>
              <Typography variant="h6">
                {formatNumber(metrics.supply)} PITA
              </Typography>
            </div>
          </div>

          {/* Price Chart */}
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={metrics.priceHistory}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis 
                  dataKey="timestamp"
                  tickFormatter={(timestamp) => {
                    return new Date(timestamp).toLocaleTimeString();
                  }}
                />
                <YAxis 
                  domain={['auto', 'auto']}
                  tickFormatter={(value) => formatUSD(value)}
                />
                <Tooltip 
                  formatter={(value: number) => [formatUSD(value), 'Price']}
                  labelFormatter={(label) => new Date(label).toLocaleString()}
                />
                <Line 
                  type="monotone"
                  dataKey="price"
                  stroke="#8884d8"
                  dot={false}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </div>

        {/* Field Metrics */}
        {metrics.fieldStrength !== undefined && (
          <div className="mt-6 space-y-4">
            <Typography variant="h6" className="mb-4">
              Field Metrics
            </Typography>
            
            <div>
              <Typography variant="subtitle2" color="text.secondary">
                Field Strength
              </Typography>
              <div className="w-full bg-gray-200 rounded-full h-2">
                <div 
                  className="bg-blue-600 h-2 rounded-full"
                  style={{ width: `${metrics.fieldStrength}%` }}
                />
              </div>
              <Typography variant="body2" className="mt-1">
                {metrics.fieldStrength.toFixed(2)}%
              </Typography>
            </div>

            {metrics.fieldSynchronization !== undefined && (
              <div>
                <Typography variant="subtitle2" color="text.secondary">
                  Field Synchronization
                </Typography>
                <div className="w-full bg-gray-200 rounded-full h-2">
                  <div 
                    className="bg-green-600 h-2 rounded-full"
                    style={{ width: `${metrics.fieldSynchronization}%` }}
                  />
                </div>
                <Typography variant="body2" className="mt-1">
                  {metrics.fieldSynchronization.toFixed(2)}%
                </Typography>
              </div>
            )}
          </div>
        )}
      </CardContent>
    </Card>
  );
};

export default TokenMetrics;
=== ./VotingInterface.tsx ===
// Main App: src/views/components/dashboard/VotingInterface.tsx
import React, { useState, useEffect } from 'react';
import { ContractService } from './contractService';
import { ethers } from 'ethers';
import { useWeb3Manager } from 'hooks/useWeb3Manager';
import { AuthorityService, VotingCapabilityType, AuthorityStateResponse } from 'services/AuthorityService';
import { ProposalState as ProposalLifecycleState } from 'services/ProposalLifecycle';
import { ProposalIntegrationService } from './ProposalIntegrationService';
import { DAOProposal } from './ProposalTypes';
import { ProposalState as ContractProposalState } from 'types/contracts';
import { ProposalStateEnum } from 'types/contracts';

import {
  Card,
  CardContent,
  CardHeader,
  Typography,
  Button,
  LinearProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  Box,
  TextField,
  CircularProgress,
  Chip,
  Alert
} from '@mui/material';

import { Loader2, ThumbsUp, ThumbsDown, Timer, Users, Shield } from 'lucide-react';

// Extend the original proposal interface to support dual voting
interface VotingInterfaceProps {
  proposal: {
    id: string;
    title: string;
    description: string;
    proposer?: string;
    startTime?: number;
    endTime?: number;
    forVotes?: ethers.BigNumber;
    againstVotes?: ethers.BigNumber;
    executed?: boolean;
    category?: number;
    isPermanent?: boolean;
  };
}

// Enhanced state interface to track both voting systems
interface ProposalStateData {
  state: ContractProposalState;
  endEpoch: number;
  forVotes: ethers.BigNumber;
  againstVotes: ethers.BigNumber;
  stage?: number;
  channelVotes?: {
    forVotes: number;
    againstVotes: number;
  };
}

// Enum for proposal states
const ProposalState = {
  Pending: 0,
  Active: 1,
  Canceled: 2,
  Defeated: 3,
  Succeeded: 4,
  Executed: 5
} as const;

type ProposalStateType = typeof ProposalState[keyof typeof ProposalState];

const formatCapability = (key: string): string => {
  switch (key) {
    case 'daoStructure': return 'DAO Structure';
    case 'complexGovernance': return 'Complex Governance';
    case 'sovereignAuthority': return 'Sovereign Authority';
    default: return key;
  }
};

const VotingInterface: React.FC<VotingInterfaceProps> = ({ proposal }) => {
  const [loading, setLoading] = useState<boolean>(false);
  const [proposalState, setProposalState] = useState<ProposalStateData | null>(null);
  const [timeRemaining, setTimeRemaining] = useState<string>('');
  const [voteAmount, setVoteAmount] = useState<string>('');
  const [voteForDialogOpen, setVoteForDialogOpen] = useState<boolean>(false);
  const [voteAgainstDialogOpen, setVoteAgainstDialogOpen] = useState<boolean>(false);
  const [contractService, setContractService] = useState<ContractService | null>(null);
  const [authorityState, setAuthorityState] = useState<AuthorityStateResponse | null>(null);
  const { web3State } = useWeb3Manager();
  
useEffect(() => {
  if (!contractService) {
    console.error("[VotingInterface] Contract service not initialized.");
  }

  if (!!contractService) {
    console.error("[VotingInterface] Contract service initialized.");
  }
}, []);
  
  //const integrationService = new ProposalIntegrationService(contractService);

  // Initialize contract and integration services
  useEffect(() => {
    const initializeContract = async (): Promise<void> => {
      try {
        if (!window.ethereum) {
          throw new Error('Web3 provider not found');
        }
        
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        
        const signer = provider.getSigner();
        const address = await signer.getAddress();
        
        console.log('Connected with address:', address);
        
        const service = new ContractService(
          provider,
          '0x23767A0C9A072C6A081C27A1C03Cc95B9F9cc6E0'
        );
        
        const testCall = await service.contract.provider;
        if (!testCall) {
          throw new Error('Contract connection failed');
        }
        
        setContractService(service);
        
        // Enhanced state fetching to include channel votes
        if (proposal.id) {
          //const onChainState = await service.getProposalState(parseInt(proposal.id));
          
          // When setting proposal state, transform the response properly
        const response = await service.getProposalState(parseInt(proposal.id));
        setProposalState({
          state: response.data.currentState,
          endEpoch: response.data.endEpoch,
          forVotes: response.data.forVotes,
          againstVotes: response.data.againstVotes,
          stage: response.data.stage || 0,
          channelVotes: response.ravenVotes
        });
          
          // Get channel votes if available
          let channelVotes;
          if (service.raven) {
            const messages = await service.raven.getChannelMessages(proposal.id);
            channelVotes = {
              forVotes: messages.filter(m => m.content === 'VOTE_FOR').length,
              againstVotes: messages.filter(m => m.content === 'VOTE_AGAINST').length
            };
          }

          setProposalState({
            ...response,
            channelVotes
          });
        }
      } catch (error) {
        console.error('Error initializing contract:', error);
      }
    };

    initializeContract();
  }, [proposal.id]);

  // Preserve existing time remaining logic
  useEffect(() => {
    const updateTimeRemaining = (): void => {
      if (!proposalState) return;

      const now = Math.floor(Date.now() / 1000);
      const end = proposalState.endEpoch;
      const diff = end - now;

      if (diff <= 0) {
        setTimeRemaining('Voting ended');
        return;
      }

      const days = Math.floor(diff / (24 * 60 * 60));
      const hours = Math.floor((diff % (24 * 60 * 60)) / (60 * 60));
      const minutes = Math.floor((diff % (60 * 60)) / 60);

      setTimeRemaining(`${days}d ${hours}h ${minutes}m remaining`);
    };

    updateTimeRemaining();
    const interval = setInterval(updateTimeRemaining, 60000);
    return () => clearInterval(interval);
  }, [proposalState]);

  // Preserve authority state loading
  useEffect(() => {
    const loadAuthorityState = async (): Promise<void> => {
      if (!contractService || !web3State.account) return;
      
      try {
        const authorityService = AuthorityService.getInstance(contractService);
        const state = await authorityService.getCurrentState(web3State.account);
        setAuthorityState(state);
      } catch (error) {
        console.error('Error loading authority state:', error);
      }
    };

    loadAuthorityState();
  }, [contractService, web3State.account]);
  
  const closeVoteDialogs = (): void => {
    setVoteForDialogOpen(false);
    setVoteAgainstDialogOpen(false);
    setVoteAmount('');
  };

  // Enhanced vote handling
  const handleVote = async (support: boolean): Promise<void> => {
    if (!contractService || !voteAmount || !authorityState || !web3State.account) return;
    
    setLoading(true);
    try {
      const authorityService = AuthorityService.getInstance(contractService);
      const baseAmount = ethers.utils.parseEther(voteAmount);
      
      // Calculate weighted voting power
      // Use BigNumber consistently for vote amounts
      const votingPower = ethers.BigNumber.from(
        (await authorityService.getVotingPower(
          web3State.account,
          BigInt(baseAmount.toString())
        )).toString()
      );

      // Handle veto votes
      if (!support && await authorityService.hasCapability(
        web3State.account,
        VotingCapabilityType.VETO_VOTE
      )) {
        await handleVetoVote(BigInt(votingPower.toString()));
        return;
      }

      // Use integration service for voting
      const integrationService = new ProposalIntegrationService(contractService);
      await integrationService.castVote(
        proposal.id,
        support,
        ethers.BigNumber.from(votingPower.toString())
      );
      
      // Update both on-chain and channel state
      const newState = await contractService.getProposalState(parseInt(proposal.id));
      let channelVotes = proposalState?.channelVotes;
      
      if (contractService.raven) {
        const messages = await contractService.raven.getChannelMessages(proposal.id);
        channelVotes = {
          forVotes: messages.filter(m => m.content === 'VOTE_FOR').length,
          againstVotes: messages.filter(m => m.content === 'VOTE_AGAINST').length
        };
      }

      setProposalState({
        ...newState,
        channelVotes
      });
      
      closeVoteDialogs();
    } catch (error) {
      console.error('Error casting vote:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleVetoVote = async (votingPower: bigint): Promise<void> => {
    // Implementation for veto vote handling
    // Add your veto vote logic here
  };

  const hasCapability = (capability: VotingCapabilityType): boolean => {
    return authorityState?.capabilities.includes(capability) || false;
  };

  // Add authority-specific UI elements
  const renderAuthorityIndicators = (): React.ReactNode => {
    if (!authorityState) return null;

    return (
      <Box sx={{ mt: 2, display: 'flex', gap: 1 }}>
        {Object.values(VotingCapabilityType).map((capability) => (
          <Chip
            key={capability}
            label={formatCapability(capability)}
            color={hasCapability(capability) ? 'primary' : 'default'}
            size="small"
          />
        ))}
      </Box>
    );
  };

  if (!proposalState) {
    return (
      <Card>
        <CardContent>
          <Box display="flex" justifyContent="center" p={3}>
            <CircularProgress />
          </Box>
        </CardContent>
      </Card>
    );
  }

  const totalVotes = proposalState.forVotes.add(proposalState.againstVotes);
  const forPercentage = totalVotes.gt(0)
    ? proposalState.forVotes.mul(100).div(totalVotes).toNumber()
    : 0;
  const againstPercentage = 100 - forPercentage;

  const isVotingActive = proposalState.state === ProposalStateEnum.ACTIVE;

  return (
    <Card>
      <CardHeader
        title={
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <Typography variant="h6">
              {proposal.title}
              <Typography component="span" variant="subtitle2" sx={{ ml: 1, color: 'text.secondary' }}>
                #{proposal.id}
              </Typography>
            </Typography>
            {proposal.isPermanent && (
              <Chip
                icon={<Shield size={16} />}
                label="Permanent Proposal"
                color="primary"
                variant="outlined"
              />
            )}
          </Box>
        }
        subheader={
          <Box sx={{ mt: 1 }}>
            <Typography variant="body2" color="text.secondary">
              {proposal.description}
            </Typography>
            <Box sx={{ 
              display: 'flex', 
              alignItems: 'center', 
              gap: 2, 
              mt: 1,
              color: 'text.secondary'
            }}>
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <Box sx={{ mr: 1 }}>
                <Timer size={16} />
              </Box>
              {timeRemaining}
            </Box>
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <Box sx={{ mr: 1 }}>
                <Users size={16} />
              </Box>
              {totalVotes.toString()} votes
            </Box>
            </Box>
          </Box>
        }
        action={renderAuthorityIndicators()}
      />

      <CardContent>
        {/* Voting Progress */}
        <Box sx={{ mb: 4 }}>
          {/* For Votes */}
          <Box sx={{ mb: 2 }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
              <Typography variant="body2">For</Typography>
              <Typography variant="body2">{forPercentage}%</Typography>
            </Box>
            <LinearProgress 
              variant="determinate" 
              value={forPercentage}
              sx={{
                height: 8,
                backgroundColor: 'error.light',
                '& .MuiLinearProgress-bar': {
                  backgroundColor: 'success.main'
                }
              }}
            />
            <Typography variant="body2" color="text.secondary" sx={{ mt: 0.5 }}>
              {ethers.utils.formatEther(proposalState.forVotes)} votes
            </Typography>
          </Box>

          {/* Against Votes */}
          <Box sx={{ mb: 2 }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
              <Typography variant="body2">Against</Typography>
              <Typography variant="body2">{againstPercentage}%</Typography>
            </Box>
            <LinearProgress 
              variant="determinate" 
              value={againstPercentage}
              sx={{
                height: 8,
                backgroundColor: 'success.light',
                '& .MuiLinearProgress-bar': {
                  backgroundColor: 'error.main'
                }
              }}
            />
            <Typography variant="body2" color="text.secondary" sx={{ mt: 0.5 }}>
              {ethers.utils.formatEther(proposalState.againstVotes)} votes
            </Typography>
          </Box>
        </Box>

        {/* Voting Actions */}
        <Box sx={{ 
          display: 'flex', 
          justifyContent: 'space-between', 
          mt: 2 
        }}>
          {isVotingActive && (
            <>
              <Button
                variant="outlined"
                color="error"
                onClick={() => setVoteAgainstDialogOpen(true)}
                disabled={loading}
                startIcon={<ThumbsDown />}
                sx={{ flex: 1, mr: 1 }}
              >
                Vote Against
              </Button>
              <Button
                variant="contained"
                color="success"
                onClick={() => setVoteForDialogOpen(true)}
                disabled={loading}
                startIcon={<ThumbsUp />}
                sx={{ flex: 1, ml: 1 }}
              >
                Vote For
              </Button>
            </>
          )}
        </Box>

        {/* Vote For Dialog */}
        <Dialog 
          open={voteForDialogOpen} 
          onClose={() => setVoteForDialogOpen(false)}
        >
          <DialogTitle>Cast Vote For Proposal</DialogTitle>
          <DialogContent>
            <DialogContentText sx={{ mb: 2 }}>
              Enter the amount of tokens you want to vote with:
            </DialogContentText>
            <TextField
              label="Vote Amount"
              type="number"
              value={voteAmount}
              onChange={(e) => setVoteAmount(e.target.value)}
              fullWidth
              sx={{ mb: 2 }}
            />
            <DialogContentText color="warning.main">
              This action cannot be undone.
            </DialogContentText>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setVoteForDialogOpen(false)}>Cancel</Button>
            <Button
              onClick={() => handleVote(true)}
              variant="contained"
              color="success"
              disabled={loading || !voteAmount}
            >
              {loading ? <Loader2 className="animate-spin" /> : 'Confirm Vote'}
            </Button>
          </DialogActions>
        </Dialog>

        {/* Vote Against Dialog */}
        <Dialog 
          open={voteAgainstDialogOpen} 
          onClose={() => setVoteAgainstDialogOpen(false)}
        >
          <DialogTitle>Cast Vote Against Proposal</DialogTitle>
          <DialogContent>
            <DialogContentText sx={{ mb: 2 }}>
              Enter the amount of tokens you want to vote with:
            </DialogContentText>
            <TextField
              label="Vote Amount"
              type="number"
              value={voteAmount}
              onChange={(e) => setVoteAmount(e.target.value)}
              fullWidth
              sx={{ mb: 2 }}
            />
            <DialogContentText color="warning.main">
              This action cannot be undone.
            </DialogContentText>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setVoteAgainstDialogOpen(false)}>Cancel</Button>
            <Button
              onClick={() => handleVote(false)}
              variant="contained"
              color="error"
              disabled={loading || !voteAmount}
            >
              {loading ? <Loader2 className="animate-spin" /> : 'Confirm Vote'}
            </Button>
          </DialogActions>
        </Dialog>
      </CardContent>
    </Card>
  );
};

export default VotingInterface;
=== ./ProposalDisplay.tsx ===
import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import { 
  Card, 
  CardContent,
  CardHeader,
  Typography,
  Box,
  LinearProgress,
  Button,
  CircularProgress,
  Grid
} from '@mui/material';
import { ThumbsUp, ThumbsDown, Timer } from 'lucide-react';
import { ProposalIntegrationService } from './ProposalIntegrationService';
import { ContractService } from './contractService';
import { Proposal as ContractProposal } from 'types/contracts';
import type { ProposalState } from 'types/contracts';

// Define our component's version of the Proposal interface that matches the contract type
interface Proposal extends Omit<ContractProposal, 'currentState'> {
  currentState: ProposalState;
  forVotes: ethers.BigNumber;
  againstVotes: ethers.BigNumber;
}

interface ProposalDisplayProps {
  contractService: ContractService;
}

const ProposalDisplay: React.FC<ProposalDisplayProps> = ({ contractService }) => {
  const [loading, setLoading] = useState<boolean>(true);
  const [proposals, setProposals] = useState<Proposal[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchProposals = async () => {
      try {
        if (!contractService) {
          console.error('Contract service not available');
          setError('Please connect your wallet to view proposals');
          return;
        }

        setLoading(true);
        console.log('Fetching proposals...');
        const integrationService = new ProposalIntegrationService(contractService);
        const fetchedProposals = await integrationService.getAllProposals();
        console.log('Fetched proposals:', fetchedProposals);

        if (fetchedProposals.length === 0) {
          console.log('No proposals found or error fetching proposals');
        }

        setProposals(fetchedProposals as Proposal[]);
      } catch (err) {
        console.error('Error fetching proposals:', err);
        setError(err instanceof Error ? err.message : 'An unknown error occurred');
      } finally {
        setLoading(false);
      }
    };

    fetchProposals();
  }, [contractService]);

  const calculateVotePercentage = (forVotes: ethers.BigNumber, againstVotes: ethers.BigNumber, isFor: boolean): number => {
    const totalVotes = forVotes.add(againstVotes);
    if (totalVotes.isZero()) return 0;
    
    const relevantVotes = isFor ? forVotes : againstVotes;
    return totalVotes.gt(0) 
      ? Number(relevantVotes.mul(100).div(totalVotes)) 
      : 0;
  };

  const isProposalActive = (state: ProposalState): boolean => {
    return state === ProposalState.ACTIVE;
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" p={3}>
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Box p={3}>
        <Typography color="error">Error loading proposals: {error}</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
      {proposals.map((proposal) => (
        <Card key={proposal.id}>
          <CardHeader
            title={
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                <Typography variant="h6">
                  {proposal.title}
                  <Typography
                    component="span"
                    variant="subtitle2"
                    sx={{ ml: 1, color: 'text.secondary' }}
                  >
                    #{proposal.id}
                  </Typography>
                </Typography>
              </Box>
            }
            subheader={
              <Box sx={{ mt: 1 }}>
                <Typography variant="body2" color="text.secondary">
                  {proposal.description}
                </Typography>
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mt: 1, color: 'text.secondary' }}>
                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    <Timer className="mr-1 h-4 w-4" />
                    {isProposalActive(proposal.currentState) ? 'Active' : 'Ended'}
                  </Box>
                </Box>
              </Box>
            }
          />

          <CardContent>
            <Box sx={{ mb: 4 }}>
              {/* For Votes */}
              <Box sx={{ mb: 2 }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                  <Typography variant="body2">For</Typography>
                  <Typography variant="body2">
                    {ethers.utils.formatEther(proposal.forVotes)} votes
                  </Typography>
                </Box>
                <LinearProgress
                  variant="determinate"
                  value={calculateVotePercentage(proposal.forVotes, proposal.againstVotes, true)}
                  sx={{
                    height: 8,
                    borderRadius: 1,
                    backgroundColor: 'error.light',
                    '& .MuiLinearProgress-bar': {
                      backgroundColor: 'success.main'
                    }
                  }}
                />
              </Box>

              {/* Against Votes */}
              <Box sx={{ mb: 2 }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                  <Typography variant="body2">Against</Typography>
                  <Typography variant="body2">
                    {ethers.utils.formatEther(proposal.againstVotes)} votes
                  </Typography>
                </Box>
                <LinearProgress
                  variant="determinate"
                  value={calculateVotePercentage(proposal.forVotes, proposal.againstVotes, false)}
                  sx={{
                    height: 8,
                    borderRadius: 1,
                    backgroundColor: 'success.light',
                    '& .MuiLinearProgress-bar': {
                      backgroundColor: 'error.main'
                    }
                  }}
                />
              </Box>
            </Box>

            {isProposalActive(proposal.currentState) && (
              <Grid container spacing={2}>
                <Grid item xs={6}>
                  <Button
                    variant="outlined"
                    color="error"
                    fullWidth
                    startIcon={<ThumbsDown />}
                  >
                    Vote Against
                  </Button>
                </Grid>
                <Grid item xs={6}>
                  <Button
                    variant="contained"
                    color="success"
                    fullWidth
                    startIcon={<ThumbsUp />}
                  >
                    Vote For
                  </Button>
                </Grid>
              </Grid>
            )}
          </CardContent>
        </Card>
      ))}
    </Box>
  );
};

export default ProposalDisplay;
=== ./UnifiedFieldsSystem.tsx ===
// Main App: src/views/components/dashboard/UnifiedFieldsSystem.tsx

import React, { useState, useEffect } from 'react';
import {
  Card,
  CardContent,
  CardHeader,
  Typography,
  Button,
  LinearProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  Box,
  TextField
} from '@mui/material';
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer
} from 'recharts';
import { useWeb3Manager } from 'hooks/useWeb3Manager';

// First, let's define our interfaces and types
interface FieldState {
  level: number;
  strength: number;
  synchronization: number;
  dimensionalReach: number;
  unityProgress: number;
}

interface FieldMetric {
  timestamp: string;
  strength: number;
  synchronization: number;
}

interface FieldOperationsControlProps {
  fieldState: FieldState;
  onOperation: (operation: FieldOperation) => void;
}

type FieldOperation = 'synchronize' | 'optimize' | 'evolve';

// Constants for field states
const FIELD_STATES = {
  COMPLETE_UNITY: 50.00000000,
  UNIFIED_FIELDS: {
    FIRST: 50.92592593,
    SECOND: 51.85185185,
    THIRD: 52.77777778
  },
  INTEGRATION_FIELDS: {
    PRIMARY: 53.70370370,
    SECONDARY: 54.62962963,
    TERTIARY: 55.55555556
  }
} as const;

// Field strength calculation helper
const calculateFieldStrength = (level: number): number => {
  if (level < 50) return 0;
  const normalizedLevel = (level - 50) / 50;
  return Math.pow(normalizedLevel, 2) * 100;
};

// Helper function to format operation names for display
const formatOperationName = (operation: FieldOperation): string => {
  return operation.charAt(0).toUpperCase() + operation.slice(1);
};

// Progress component with proper typing
interface ProgressProps {
  value: number;
  max: number;
}

const Progress: React.FC<ProgressProps> = ({ value, max }) => (
  <div className="w-full bg-gray-200 rounded-full h-2.5">
    <div
      className="bg-blue-600 h-2.5 rounded-full"
      style={{ width: `${(value / max) * 100}%` }}
    />
  </div>
);

const UnifiedFieldsSystem: React.FC = () => {
  const { web3State, contractService } = useWeb3Manager();
  const [fieldState, setFieldState] = useState<FieldState>({
    level: FIELD_STATES.COMPLETE_UNITY,
    strength: 0,
    synchronization: 0,
    dimensionalReach: 0,
    unityProgress: 0
  });

useEffect(() => {
  if (!contractService) {
    console.error("[UnifiedFieldsSystem] Contract service not initialized.");
  }

  if (!!contractService) {
    console.error("[UnifiedFieldsSystem] Contract service initialized.");
  }
}, []);

  // Field metrics data generation
  const getFieldMetrics = (): FieldMetric[] => {
    // This would typically fetch historical data from your contract
    // For now, returning placeholder data
    return Array.from({ length: 10 }, (_, i) => ({
      timestamp: new Date(Date.now() - i * 86400000).toLocaleDateString(),
      strength: fieldState.strength - i * 2,
      synchronization: fieldState.synchronization - i * 1.5
    }));
  };

  useEffect(() => {
    const loadFieldState = async () => {
      try {
        if (!contractService) {
          throw new Error("Contract service not initialized");
        }

        const currentLevel = await contractService.logicConstituent.getDomainState();
        const newFieldState: FieldState = {
          level: currentLevel,
          strength: calculateFieldStrength(currentLevel),
          synchronization: await getFieldSynchronization(),
          dimensionalReach: await getDimensionalReach(),
          unityProgress: 0 // Will be calculated after setting state
        };
        
        // Calculate unity progress after other values are set
        newFieldState.unityProgress = ((newFieldState.level - 50) / 50) * 100;
        
        setFieldState(newFieldState);
      } catch (error) {
        console.error('Failed to load field state:', error);
      }
    };

    loadFieldState();
  }, [contractService, web3State.account]);

  const getFieldSynchronization = async (): Promise<number> => {
    if (!contractService) {
      return 0;
    }
    try {
      const totalSupply = await contractService.daoToken.totalSupply();
      const dailyVolume = await contractService.daoToken.dailyAllocation();
      return (Number(dailyVolume) / Number(totalSupply)) * 100;
    } catch (error) {
      console.error('Failed to get field synchronization:', error);
      return 0;
    }
  };

const getDimensionalReach = async (): Promise<number> => {
    if (!contractService) {
        return 0;
    }
    try {
        // activeUserCount returns a BigNumber from the contract
        const activeUsers = await contractService.daoToken.activeUserCount();
        const maxUsers = 11664; // From DAOToken constant TARGET_USERS

        // Convert the BigNumber to a regular number before arithmetic operations
        const activeUsersNumber = activeUsers.toNumber();

        // Now we can safely perform the percentage calculation
        const percentage = (activeUsersNumber / maxUsers) * 100;

        // Ensure we don't exceed 100%
        return Math.min(percentage, 100);
    } catch (error) {
        console.error('Failed to get dimensional reach:', error);
        return 0;
    }
};

  const handleFieldOperation = async (operation: FieldOperation) => {
    if (!contractService) {
      console.error('Contract service not initialized');
      return;
    }

    try {
      switch (operation) {
        case 'synchronize':
          await contractService.logicConstituent.synchronizeField();
          break;
        case 'optimize':
          await contractService.logicConstituent.optimizeField();
          break;
        case 'evolve':
          await contractService.logicConstituent.evolveField();
          break;
      }
      // Reload field state after operation
      const currentLevel = await contractService.logicConstituent.getDomainState();
      setFieldState(prev => ({
        ...prev,
        level: currentLevel,
        strength: calculateFieldStrength(currentLevel)
      }));
    } catch (error) {
      console.error(`Failed to perform field operation ${operation}:`, error);
    }
  };

  return (
    <div className="space-y-6">
      <div className="bg-white rounded-lg shadow-md p-6">
        <div className="mb-4">
          <h2 className="text-2xl font-bold">Unified Fields</h2>
          <p className="text-sm text-gray-500">
            Current Level: {fieldState.level.toFixed(8)}
          </p>
        </div>

        <div className="space-y-6">
          {/* Field Strength Indicator */}
          <div>
            <label className="text-sm font-medium">Field Strength</label>
            <Progress value={fieldState.strength} max={100} />
            <p className="text-sm text-gray-500">
              {fieldState.strength.toFixed(2)}% Capacity
            </p>
          </div>

          {/* Synchronization Status */}
          <div>
            <label className="text-sm font-medium">Field Synchronization</label>
            <Progress value={fieldState.synchronization} max={100} />
            <p className="text-sm text-gray-500">
              {fieldState.synchronization.toFixed(2)}% Synchronized
            </p>
          </div>

          {/* Field Metrics Visualization */}
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={getFieldMetrics()}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="timestamp" />
                <YAxis />
                <Tooltip />
                <Line 
                  type="monotone" 
                  dataKey="strength" 
                  stroke="#8884d8" 
                  name="Field Strength"
                />
                <Line 
                  type="monotone" 
                  dataKey="synchronization" 
                  stroke="#82ca9d"
                  name="Synchronization"
                />
              </LineChart>
            </ResponsiveContainer>
          </div>

          {/* Unity Progress */}
          {fieldState.level >= FIELD_STATES.UNIFIED_FIELDS.FIRST && (
            <div>
              <label className="text-sm font-medium">Progress to Unity</label>
              <Progress value={fieldState.unityProgress} max={100} />
              <p className="text-sm text-gray-500">
                {fieldState.unityProgress.toFixed(2)}% Complete
              </p>
            </div>
          )}
        </div>
      </div>

      {/* Field Operations Control */}
      <FieldOperationsControl 
        fieldState={fieldState}
        onOperation={handleFieldOperation}
      />
    </div>
  );
};

// Field Operations Control Component
const FieldOperationsControl: React.FC<FieldOperationsControlProps> = ({ 
  fieldState, 
  onOperation 
}) => {
  const getAvailableOperations = (): FieldOperation[] => {
    if (fieldState.level >= FIELD_STATES.INTEGRATION_FIELDS.PRIMARY) {
      return ['synchronize', 'optimize', 'evolve'];
    }
    if (fieldState.level >= FIELD_STATES.UNIFIED_FIELDS.FIRST) {
      return ['synchronize', 'optimize'];
    }
    return ['synchronize'];
  };

  return (
    <div className="bg-white rounded-lg shadow-md p-6">
      <h3 className="text-lg font-semibold mb-4">Field Operations</h3>
      <div className="space-y-4">
        {getAvailableOperations().map(operation => (
          <button
            key={operation}
            onClick={() => onOperation(operation)}
            className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
          >
            {formatOperationName(operation)}
          </button>
        ))}
      </div>
    </div>
  );
};

export default UnifiedFieldsSystem;
=== ./DAODashboard.tsx ===
// Main App: src/views/components/dashboard/DAODashboard.tsx

import React, { useEffect, useState } from 'react';
import { useWeb3Manager } from 'hooks/useWeb3Manager';
import { ContractService } from './contractService';
import { ethers } from 'ethers';
//import { ProposalState } from 'services/ProposalLifecycle';

// Material UI Imports
import { 
  Card,
  CardHeader,
  CardContent,
  Typography,
  Tabs,
  Tab,
  Button,
  Alert,
  AlertTitle,
  CircularProgress,
  Box,
  Grid,
  LinearProgress,
  Chip,
  Container,
  Paper,
  Divider
} from '@mui/material';

// Type Imports
import {
  DAOStatus,
  DomainState,
  IntegrationState,
  ComponentStateProps,
  ProposalListProps,
  TokenMetricsProps
} from 'types/dao';
import type { Web3ManagerHook } from 'types/dao';

// Chart Components
import { 
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  LineChart,
  Line 
} from 'recharts';

// Icon Imports
import { 
  Loader2, 
  TrendingUp, 
  Users, 
  FileText, 
  Activity, 
  LayoutDashboard, 
  Vote, 
  Wallet, 
  Settings, 
  Shield 
} from 'lucide-react';

import { 
  AccountTree as AccountTreeIcon,
  SwapHoriz as SwapHorizIcon,
  Security as SecurityIcon
} from '@mui/icons-material';

// Component Imports
import ProposalCreation from './ProposalCreation';
import ProposalList from './ProposalList';
import VotingInterface from './VotingInterface';
import TokenMetrics from './TokenMetrics';
import MembershipStats from './MembershipStats';
import UnifiedFieldsSystem from './UnifiedFieldsSystem';
import LegalProgressionSystem from './LegalProgressionSystem';
import DAOGovernance from './DAOGovernance';
import DomainMonitor from './DomainMonitor';

// Placeholder Component Interfaces
interface DepartmentManagerProps extends ComponentStateProps {}
interface PolicyManagerProps extends ComponentStateProps {}
interface RoleManagerProps extends ComponentStateProps {}
interface ParameterManagerProps extends ComponentStateProps {}
interface TreasuryManagerProps extends ComponentStateProps {}
interface VetoManagerProps extends ComponentStateProps {}
interface StrategyManagerProps extends ComponentStateProps {}
interface EmergencyControlsProps extends ComponentStateProps {}
interface ProtocolManagerProps extends ComponentStateProps {}

// Placeholder Components - These will be implemented later
const DepartmentManager: React.FC<ComponentStateProps> = () => <div>Department Manager</div>;
const PolicyManager: React.FC<ComponentStateProps> = () => <div>Policy Manager</div>;
const RoleManager: React.FC<ComponentStateProps> = () => <div>Role Manager</div>;
const ParameterManager: React.FC<ComponentStateProps> = () => <div>Parameter Manager</div>;
const TreasuryManager: React.FC<ComponentStateProps> = () => <div>Treasury Manager</div>;
const VetoManager: React.FC<ComponentStateProps> = () => <div>Veto Manager</div>;
const StrategyManager: React.FC<ComponentStateProps> = () => <div>Strategy Manager</div>;
const EmergencyControls: React.FC<ComponentStateProps> = () => <div>Emergency Controls</div>;
const ProtocolManager: React.FC<ComponentStateProps> = () => <div>Protocol Manager</div>;

// Helper Functions
const getCrossDAOCapabilities = (level: number): string[] => {
  const capabilities: string[] = [];
  if (level >= 25.93) capabilities.push('CROSS_DAO_VOTING');
  if (level >= 28.70) capabilities.push('PRIVATE_TRANSACTIONS');
  if (level >= 31.48) capabilities.push('AUTHORITY_DELEGATION');
  return capabilities;
};

const calculatePowerWeight = (level: number): number => {
  return Math.floor((level - 25.00) / 5) + 1;
};

const getCapabilityDescription = (capability: string): string => {
  const descriptions: Record<string, string> = {
    DAO_STRUCTURE: 'Manage organizational structure',
    COMPLEX_GOVERNANCE: 'Advanced governance features',
    SOVEREIGN_AUTHORITY: 'Full sovereign control'
  };
  return descriptions[capability] || capability;
};

const formatCapability = (key: string): string => {
  switch (key) {
    case 'daoStructure': return 'DAO Structure';
    case 'complexGovernance': return 'Complex Governance';
    case 'sovereignAuthority': return 'Sovereign Authority';
    default: return key;
  }
};

// Loading Component
const LoadingView: React.FC = () => (
  <Box className="flex justify-center items-center min-h-[50vh]">
    <Box className="text-center">
      <CircularProgress size={40} className="mb-4" />
      <Typography variant="h6">Loading DAO Data...</Typography>
    </Box>
  </Box>
);

// Error View Component
const ErrorView: React.FC<{ error: string }> = ({ error }) => (
  <Alert severity="error" className="m-4">
    <AlertTitle>Error</AlertTitle>
    {error}
  </Alert>
);

// MetricCard Component
interface MetricCardProps {
  icon: React.ReactNode;
  value: string | number;
  label: string;
  progress?: number;
}

const MetricCard: React.FC<MetricCardProps> = ({ icon, value, label, progress }) => (
  <Card className="h-full">
    <CardContent>
      <Box className="mb-2">
        {icon}
      </Box>
      <Typography variant="h5" component="div">
        {value}
      </Typography>
      <Typography color="textSecondary">
        {label}
      </Typography>
      {progress !== undefined && (
        <Box className="mt-2">
          <LinearProgress 
            variant="determinate" 
            value={progress}
            className="h-2 rounded"
          />
        </Box>
      )}
    </CardContent>
  </Card>
);

// Section Header Component
interface SectionHeaderProps {
  title: string;
  description?: string;
}

const SectionHeader: React.FC<SectionHeaderProps> = ({ title, description }) => (
  <Box className="mb-4">
    <Typography variant="h6" component="h2">
      {title}
    </Typography>
    {description && (
      <Typography variant="body2" color="textSecondary">
        {description}
      </Typography>
    )}
    <Divider className="mt-2" />
  </Box>
);

// To be continued in Part 2...

// DAODashboard.tsx - Part 2: Governance Components and State Management

// Basic DAO Structure Component - Handles foundational governance features
const BasicDAOStructure: React.FC<{ state: DomainState }> = ({ state }) => {
  const [currentTab, setCurrentTab] = useState<string>("departments");
  
  const handleTabChange = (_event: React.SyntheticEvent, newValue: string) => {
    setCurrentTab(newValue);
  };
  
  return (
    <Card className="h-full">
      <CardHeader title={
        <SectionHeader 
          title="DAO Structure" 
          description="Manage core organizational components"
        />
      } />
      <CardContent>
        <Box className="mb-4">
          <Tabs 
            value={currentTab} 
            onChange={handleTabChange}
            variant="scrollable"
            scrollButtons="auto"
            className="border-b border-gray-200"
          >
            <Tab value="departments" label="Departments" />
            <Tab value="policies" label="Policies" />
            <Tab value="roles" label="Roles" />
          </Tabs>
        </Box>

        <Box className="mt-4">
          {currentTab === "departments" && (
            <Paper className="p-4">
              <DepartmentManager state={state} />
            </Paper>
          )}
          {currentTab === "policies" && (
            <Paper className="p-4">
              <PolicyManager state={state} />
            </Paper>
          )}
          {currentTab === "roles" && (
            <Paper className="p-4">
              <RoleManager state={state} />
            </Paper>
          )}
        </Box>
      </CardContent>
    </Card>
  );
};

// Complex Governance Component - Handles advanced governance features
const ComplexGovernance: React.FC<{ state: DomainState }> = ({ state }) => {
  const [currentTab, setCurrentTab] = useState("parameters");

  const handleTabChange = (_event: React.SyntheticEvent, newValue: string) => {
    setCurrentTab(newValue);
  };

  return (
    <Card className="h-full">
      <CardHeader title={
        <SectionHeader 
          title="Advanced Governance" 
          description="Configure complex governance parameters and controls"
        />
      } />
      <CardContent>
        <Box className="mb-4">
          <Tabs 
            value={currentTab} 
            onChange={handleTabChange}
            variant="scrollable"
            scrollButtons="auto"
            className="border-b border-gray-200"
          >
            <Tab value="parameters" label="Parameters" />
            <Tab value="treasury" label="Treasury" />
            <Tab value="veto" label="Veto Powers" />
          </Tabs>
        </Box>

        <Box className="mt-4">
          {currentTab === "parameters" && (
            <Paper className="p-4">
              <ParameterManager state={state} />
            </Paper>
          )}
          {currentTab === "treasury" && (
            <Paper className="p-4">
              <TreasuryManager state={state} />
            </Paper>
          )}
          {currentTab === "veto" && (
            <Paper className="p-4">
              <VetoManager state={state} />
            </Paper>
          )}
        </Box>
      </CardContent>
    </Card>
  );
};

// Sovereign Authority Component - Handles high-level governance control
const SovereignAuthority: React.FC<{ state: DomainState }> = ({ state }) => {
  const [currentTab, setCurrentTab] = useState("strategy");

  const handleTabChange = (_event: React.SyntheticEvent, newValue: string) => {
    setCurrentTab(newValue);
  };

  return (
    <Card className="h-full">
      <CardHeader title={
        <SectionHeader 
          title="Sovereign Control" 
          description="Manage high-level strategic controls and emergency measures"
        />
      } />
      <CardContent>
        <Box className="mb-4">
          <Tabs 
            value={currentTab} 
            onChange={handleTabChange}
            variant="scrollable"
            scrollButtons="auto"
            className="border-b border-gray-200"
          >
            <Tab value="strategy" label="Strategy" />
            <Tab value="emergency" label="Emergency" />
            <Tab value="protocol" label="Protocol" />
          </Tabs>
        </Box>

        <Box className="mt-4">
          {currentTab === "strategy" && (
            <Paper className="p-4">
              <StrategyManager state={state} />
            </Paper>
          )}
          {currentTab === "emergency" && (
            <Paper className="p-4">
              <EmergencyControls state={state} />
            </Paper>
          )}
          {currentTab === "protocol" && (
            <Paper className="p-4">
              <ProtocolManager state={state} />
            </Paper>
          )}
        </Box>
      </CardContent>
    </Card>
  );
};

// Main Dashboard Component State Management
const DAODashboard: React.FC = () => {
  // Core state management
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [daoStatus, setDaoStatus] = useState<DAOStatus | null>(null);
  const [contractService, setContractService] = useState<ContractService | null>(null);
  const [refreshKey, setRefreshKey] = useState<number>(0);
  const [domainState, setDomainState] = useState<DomainState>();
  const [integrationState, setIntegrationState] = useState<IntegrationState>();
  
  // Web3 connection management
  const { web3State } = useWeb3Manager() as Web3ManagerHook;

useEffect(() => {
  if (!contractService) {
    console.error("[DAODashboard] Contract service not initialized.");
  }

  if (!!contractService) {
    console.error("[DAODashboard] Contract service initialized.");
  }
}, []);

  // Fetch integration state data
  const fetchIntegrationState = async (service: ContractService): Promise<void> => {
    try {
      const state = await service.getProposalState(0);
      //const stage = state.data.stage?.toNumber() || 0;
      const stage = state.data.stage || 0;
  
      const baseLevel = 25.00;
      const integrationLevel = stage >= 6 ?
        baseLevel + ((stage - 6) * 2.77777778) : 
        baseLevel;

      setIntegrationState({
        level: integrationLevel,
        currentStage: {
          jurisdiction: integrationLevel >= 25.93,
          powerDomain: integrationLevel >= 28.70,
          authorityDomain: integrationLevel >= 31.48,
          integrationField: integrationLevel >= 33.33
        },
        crossDAOCapabilities: getCrossDAOCapabilities(integrationLevel),
        anonymousTransactions: integrationLevel >= 28.70
      });
    } catch (error) {
      console.error('Error fetching integration state:', error);
    }
  };

  // Fetch domain state data
  const fetchDomainState = async (service: ContractService): Promise<void> => {
    try {
      const contractState = await service.getDomainState();
      
      const appDomainState: DomainState = {
        level: contractState.level,
        capabilities: contractState.capabilities,
        governanceWeight: contractState.governanceWeight,
        lastStateUpdate: Date.now()
      };
      
      setDomainState(appDomainState);
    } catch (error) {
      console.error('Error fetching domain state:', error);
    }
  };

  // Fetch DAO status data
  const fetchDAOStatus = async (service: ContractService): Promise<void> => {
    try {
      const status = await service.getDAOStatus();
      
      const currentTime = Math.floor(Date.now() / 1000);
      const epochAge = currentTime - status.lastEpochUpdate;
      const epochProgress = (epochAge / (24 * 60 * 60)) * 100;

      const analyticsData = [
        { name: 'Transactions', value: status.analytics.transactions },
        { name: 'Active Users', value: status.analytics.users },
        { name: 'Votes Cast', value: status.analytics.votes }
      ];

      setDaoStatus({
        ...status,
        epochProgress,
        analyticsData
      });
      setLoading(false);
    } catch (error) {
      console.error('Error fetching DAO status:', error);
      setError('Failed to fetch latest DAO status');
      setLoading(false);
    }
  };

  // Initialize contract and fetch initial data
  useEffect(() => {
    const initializeContract = async () => {
      try {
        if (!window.ethereum) {
          throw new Error('No Web3 provider found');
        }
        
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []); // Important: Wait for wallet connection
        const service = new ContractService(
          provider,
          '0x23767A0C9A072C6A081C27A1C03Cc95B9F9cc6E0'
        );
        setContractService(service);

        await fetchDomainState(service);
        await fetchDAOStatus(service);
        await fetchIntegrationState(service);
      } catch (error) {
        console.error('Error initializing dashboard:', error);
        setError('Failed to initialize DAO dashboard');
        setLoading(false);
      }
    };

    initializeContract();
  }, []);

  // Handle wallet connection changes
  useEffect(() => {
    const handleAccountsChanged = () => {
      setRefreshKey(prev => prev + 1);
    };

    if (window.ethereum) {
      const ethereum = window.ethereum as any;
      ethereum.on('accountsChanged', handleAccountsChanged);
      ethereum.on('chainChanged', handleAccountsChanged);
      
      return () => {
        ethereum.removeListener('accountsChanged', handleAccountsChanged);
        ethereum.removeListener('chainChanged', handleAccountsChanged);
      };
    }
  }, []);

  // Periodic data refresh
  useEffect(() => {
    if (!contractService) return;

    const fetchData = () => {
      fetchDAOStatus(contractService);
    };

    const interval = setInterval(fetchData, 30000);
    return () => clearInterval(interval);
  }, [contractService]);

  // Loading and error states
  if (loading) return <LoadingView />;
  if (error) return <ErrorView error={error} />;

  // Main render logic will be in Part 3...
  const handleAnonymousTransaction = () => {
    console.log('Anonymous transaction initiated; must be initialized!');
  };

  return (
    <Box className="h-screen overflow-hidden flex flex-col bg-gray-50">
      {/* Top Navigation Bar */}
      <Box className="bg-white border-b border-gray-200 px-6 py-4">
        <Typography variant="h5" className="text-gray-800">
          DAO Dashboard
        </Typography>
      </Box>

      {/* Main Scrollable Content Area */}
      <Box className="flex-1 overflow-auto">
        <Container maxWidth="xl" className="py-6">
          <Grid container spacing={3}>
            {/* Quick Stats Section */}
            <Grid item xs={12}>
              <Grid container spacing={3}>
                {/* Proposal Count */}
                <Grid item xs={12} sm={6} md={3}>
                  <MetricCard
                    icon={<FileText size={24} />}
                    value={daoStatus?.proposalCount || 0}
                    label="Total Proposals"
                  />
                </Grid>

                {/* Domain Level */}
                <Grid item xs={12} sm={6} md={3}>
                  <MetricCard
                    icon={<Shield size={24} />}
                    value={domainState?.level.toFixed(8) || '0.00000000'}
                    label="Domain Level"
                    progress={((domainState?.level || 16.67) - 16.67) / (8.33) * 100}
                  />
                </Grid>

                {/* Active Users */}
                <Grid item xs={12} sm={6} md={3}>
                  <MetricCard
                    icon={<Users size={24} />}
                    value={daoStatus?.activeUserCount || 0}
                    label="Active Members"
                  />
                </Grid>

                {/* Governance Weight */}
                <Grid item xs={12} sm={6} md={3}>
                  <MetricCard
                    icon={<Vote size={24} />}
                    value={`${domainState?.governanceWeight || 1}x`}
                    label="Governance Weight"
                  />
                </Grid>
              </Grid>
            </Grid>

            {/* Main Content Grid */}
            <Grid item xs={12}>
              <Grid container spacing={3}>
                {/* Left Column - Governance and Capabilities */}
                <Grid item xs={12} lg={8}>
                  {/* Governance Controls */}
                  <Paper className="mb-6 p-4">
                    <SectionHeader title="Governance Controls" />
                    <DAOGovernance
                      domainLevel={domainState?.level || 0}
                      governanceWeight={domainState?.governanceWeight || 0}
                      stage={daoStatus?.currentStage || 0}
                    />
                  </Paper>

                  {/* Domain Capabilities */}
                  {domainState && (
                    <Paper className="mb-6 p-4">
                      <SectionHeader 
                        title="Domain Capabilities" 
                        description="Available features based on current domain level"
                      />
                      <Grid container spacing={2}>
                        {domainState.capabilities.map((cap) => (
                          <Grid item xs={12} md={4} key={cap}>
                            <Card variant="outlined" className="h-full">
                              <CardContent>
                                <Typography variant="h6">
                                  {formatCapability(cap)}
                                </Typography>
                                <Typography variant="body2" color="textSecondary">
                                  {getCapabilityDescription(cap)}
                                </Typography>
                              </CardContent>
                            </Card>
                          </Grid>
                        ))}
                      </Grid>
                    </Paper>
                  )}
                </Grid>

                {/* Right Column - Metrics and Monitoring */}
<Grid item xs={12} lg={4}>
  <div className="space-y-6"> {/* Use Tailwind's space utility */}
    <div>
      <TokenMetrics 
        key={`token-${refreshKey}`} 
      />
    </div>
    <div>
      <DomainMonitor />
    </div>
  </div>
</Grid>
              </Grid>
            </Grid>

            {/* Proposals Section */}
            <Grid item xs={12}>
              <Paper className="p-4">
                <SectionHeader title="Recent Proposals" />
                <ProposalList
                  key={`proposals-${refreshKey}`}
                  domainWeight={domainState?.governanceWeight}
                  className="w-full"
                />
              </Paper>
            </Grid>

            {/* Integration Layer */}
            {integrationState && integrationState.level >= 25.00 && (
              <Grid item xs={12}>
                <Paper className="p-4">
                  <SectionHeader 
                    title="Integration Layer" 
                    description={`Level: ${integrationState.level.toFixed(8)}`}
                  />
                  <Grid container spacing={3}>
                    {/* Cross-DAO Operations */}
                    <Grid item xs={12} md={4}>
                      <Card variant="outlined">
                        <CardContent>
                          <Box className="flex items-center gap-2 mb-4">
                            <AccountTreeIcon />
                            <Typography variant="h6">Cross-DAO Operations</Typography>
                          </Box>
                          {integrationState.crossDAOCapabilities.map((cap) => (
                            <Chip 
                              key={cap}
                              label={cap}
                              color="primary"
                              className="m-1"
                            />
                          ))}
                        </CardContent>
                      </Card>
                    </Grid>

                    {/* Anonymous Transactions */}
                    {integrationState.anonymousTransactions && (
                      <Grid item xs={12} md={4}>
                        <Card variant="outlined">
                          <CardContent>
                            <Box className="flex items-center gap-2 mb-4">
                              <SwapHorizIcon />
                              <Typography variant="h6">Private Operations</Typography>
                            </Box>
                            <Button 
                              variant="contained"
                              fullWidth
                              onClick={handleAnonymousTransaction}
                              className="mt-4"
                            >
                              New Private Transaction
                            </Button>
                          </CardContent>
                        </Card>
                      </Grid>
                    )}

                    {/* Power Domain */}
                    {integrationState.currentStage.powerDomain && (
                      <Grid item xs={12} md={4}>
                        <Card variant="outlined">
                          <CardContent>
                            <Box className="flex items-center gap-2 mb-4">
                              <SecurityIcon />
                              <Typography variant="h6">Power Domain</Typography>
                            </Box>
                            <Alert severity="info">
                              Cross-DAO governance weight: {calculatePowerWeight(integrationState.level)}
                            </Alert>
                          </CardContent>
                        </Card>
                      </Grid>
                    )}
                  </Grid>
                </Paper>
              </Grid>
            )}

            {/* Advanced Systems */}
            {domainState && integrationState && 
              domainState.level >= 25.00 && 
              integrationState.level >= 50.00 && (
                <Grid item xs={12}>
                  <Paper className="p-4">
                    <SectionHeader title="Advanced Systems" />
                    <UnifiedFieldsSystem />
                  </Paper>
                </Grid>
            )}

            {/* Legal Framework */}
            <Grid item xs={12}>
              <Paper className="p-4">
                <SectionHeader title="Legal Framework" />
                <LegalProgressionSystem />
              </Paper>
            </Grid>
          </Grid>
        </Container>
      </Box>

      {/* Status Footer */}
      <Box className="bg-white border-t border-gray-200 px-6 py-3">
        <Typography variant="body2" color="textSecondary">
          Last Updated: {new Date().toLocaleTimeString()}
        </Typography>
      </Box>
    </Box>
  );
};

export default DAODashboard;
=== ./allfiles.txt ===
=== ./DAOProfile.tsx ===
// src/views/components/dashboard/DAOProfile.tsx
import React, { useEffect, useState } from 'react';
import {
  Card,
  CardContent,
  Typography,
  Box,
  LinearProgress,
  Chip,
  Grid,
  Paper,
  Divider
} from '@mui/material';
import { 
  Award,
  TrendingUp,
  Target,
  Activity,
  Users,
  Star
} from 'lucide-react';
import { useWeb3Manager } from '../../../hooks/useWeb3Manager';
import { ProfileAnalyzer } from '../../../services/ProfileAnalyzer';
import { 
  UserProfile, 
  Connection, 
  NetworkMetrics, 
  RewardMetrics 
} from '../../../types/profile';

const DAOProfile: React.FC = () => {
  const [loading, setLoading] = useState(true);
  const [profile, setProfile] = useState<UserProfile | null>(null);
  const { web3State, contractService } = useWeb3Manager();

  useEffect(() => {
    const loadProfile = async () => {
      if (!contractService || !web3State.account) return;

      try {
        const [membershipStatus, metrics, rewardMetrics] = await Promise.all([
          contractService.getMembershipStatus(web3State.account),
          contractService.getTokenMetrics(),
          {
            daily: 8.33,
            weekly: 58.31,
            projected: 249.9
          }
        ]);

        // Convert membership status to Connection format
        const currentTimestamp = Math.floor(Date.now() / 1000);
        const daysConnected = Math.floor((currentTimestamp - membershipStatus.lastActivity) / (24 * 60 * 60));
        
        const connection: Connection = {
          address: web3State.account,
          daysConnected: daysConnected,
          rewardShare: membershipStatus.biddingShares,
          status: membershipStatus.isActive ? 'active' : 'inactive'
        };

        const networkMetrics: NetworkMetrics = {
          directConnections: membershipStatus.biddingShares,
          extendedNetwork: metrics.activeUsers,
          networkValue: parseFloat(metrics.treasuryBalance)
        };

        const analyzer = new ProfileAnalyzer(
          [connection],
          networkMetrics,
          rewardMetrics
        );

        const userProfile = analyzer.generateProfile();
        setProfile(userProfile);
      } catch (error) {
        console.error('Error loading profile:', error);
      } finally {
        setLoading(false);
      }
    };

    loadProfile();
  }, [contractService, web3State.account]);

  if (loading) {
    return (
      <Card>
        <CardContent>
          <LinearProgress />
        </CardContent>
      </Card>
    );
  }

  if (!profile) return null;

  return (
    <Card>
      <CardContent>
        <Box sx={{ mb: 4 }}>
          <Typography variant="h5" sx={{ mb: 2 }}>
            DAO Profile
          </Typography>
          <Grid container spacing={3}>
            {/* Network Score */}
            <Grid item xs={12} md={4}>
              <Paper sx={{ p: 2 }}>
                <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                  <Award className="mr-2" />
                  <Typography variant="h6">Network Score</Typography>
                </Box>
                <Typography variant="h3" sx={{ mb: 1 }}>
                  {profile.networkScore}
                </Typography>
                <Chip 
                  label={profile.engagementLevel}
                  color="primary"
                />
              </Paper>
            </Grid>

            {/* Network Growth */}
            <Grid item xs={12} md={4}>
              <Paper sx={{ p: 2 }}>
                <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                  <TrendingUp className="mr-2" />
                  <Typography variant="h6">Growth Metrics</Typography>
                </Box>
                <Box sx={{ mb: 2 }}>
                  <Typography variant="body2" color="textSecondary">
                    Network Growth Rate
                  </Typography>
                  <LinearProgress 
                    variant="determinate" 
                    value={profile.networkGrowthRate * 100}
                    sx={{ height: 8, borderRadius: 1 }}
                  />
                </Box>
                <Chip 
                  label={profile.growthTrend}
                  color={
                    profile.growthTrend === 'accelerating' ? 'success' :
                    profile.growthTrend === 'stable' ? 'primary' : 'warning'
                  }
                />
              </Paper>
            </Grid>

            {/* Networking Style */}
            <Grid item xs={12} md={4}>
              <Paper sx={{ p: 2 }}>
                <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                  <Target className="mr-2" />
                  <Typography variant="h6">Strategy</Typography>
                </Box>
                <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap' }}>
                  <Chip label={`Style: ${profile.networkingStyle}`} />
                  <Chip label={`Strategy: ${profile.connectionStrategy}`} />
                </Box>
              </Paper>
            </Grid>
          </Grid>
        </Box>

        <Divider sx={{ my: 4 }} />

        {/* Strengths and Development Areas */}
        <Grid container spacing={3}>
          <Grid item xs={12} md={6}>
            <Paper sx={{ p: 2 }}>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                <Star className="mr-2" />
                <Typography variant="h6">Unique Strengths</Typography>
              </Box>
              <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap' }}>
                {profile.uniqueStrengths.map((strength, index) => (
                  <Chip 
                    key={index}
                    label={strength}
                    color="success"
                    variant="outlined"
                  />
                ))}
              </Box>
            </Paper>
          </Grid>

          <Grid item xs={12} md={6}>
            <Paper sx={{ p: 2 }}>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                <Activity className="mr-2" />
                <Typography variant="h6">Development Areas</Typography>
              </Box>
              <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap' }}>
                {profile.developmentAreas.map((area, index) => (
                  <Chip 
                    key={index}
                    label={area}
                    color="warning"
                    variant="outlined"
                  />
                ))}
              </Box>
            </Paper>
          </Grid>
        </Grid>
      </CardContent>
    </Card>
  );
};

export default DAOProfile;
=== ./AnonymousTransactions.tsx ===
// Main App: src/views/components/dashboard/AnonymousTransactions.tsx

import React, { useState, useEffect } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  TextField,
  Button,
  Tabs,
  Tab,
  Paper,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  CircularProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Alert,
  Snackbar,
  Stack,
  Switch,
  FormControlLabel
} from '@mui/material';
import { AlertColor } from '@mui/material';
import { ethers } from 'ethers';
import { useWeb3Manager } from '../../../hooks/useWeb3Manager';

// Define interface for transaction object
interface Transaction {
  txHash: string;
  recipient: string;
  amount: ethers.BigNumber;  // Change from string to BigNumber
  creationTime: number;
  claimed: boolean;
  condition: string;
  publicKeyHash: string;    // Add to match AnonymousTransaction
  conditionHash: string;    // Add to match AnonymousTransaction
}

// Enhanced type definitions to match contract structures
interface AnonymousTransaction {
  publicKeyHash: string;
  recipient: string;
  amount: ethers.BigNumber;
  creationTime: number;
  claimed: boolean;
  conditionHash: string;
  txHash?: string;
}

// Add this interface near the top with other interfaces
interface AnonymousTransactionEvent {
  args: {
    txHash: string;
    recipient: string;
    amount: ethers.BigNumber;
    timestamp: number;
  };
}

interface IntegrationContext {
  level: number;
  powerDomain: boolean;
  maxTransactionValue: bigint;
  crossDAOEnabled: boolean;
}

interface TransactionForm {
  recipient: string;
  amount: string;
  condition: string;
  publicKey: string;
}

interface ClaimForm {
  signature: string;
  condition: string;
}

interface SnackbarState {
  open: boolean;
  message: string;
  severity: 'success' | 'info' | 'warning' | 'error';
}

// Placeholder data with proper typing
const PLACEHOLDER_TRANSACTIONS: Transaction[] = [
  {
    txHash: '0x1234...5678',
    recipient: '0xabcd...ef12',
    amount: ethers.utils.parseEther('1000'),  // Convert to BigNumber
    creationTime: Date.now() - 86400000,
    claimed: false,
    condition: 'Time lock until 2024-02-01',
    publicKeyHash: '0x000000000000000',
    conditionHash: '0x000000000000000'
  },
  {
    txHash: '0x5678...9012',
    recipient: '0xef12...3456',
    amount: ethers.utils.parseEther('500'),  // Convert to BigNumber
    creationTime: Date.now() - 172800000,
    claimed: true,
    condition: 'Requires specific signature',
    publicKeyHash: '0x000000000000000',
    conditionHash: '0x000000000000000'
  }
];

// Component props interface
interface AnonymousTransactionsProps {
  integrationContext?: IntegrationContext;
}

const AnonymousTransactions: React.FC<AnonymousTransactionsProps> = ({ integrationContext }) => {
  // State management with proper typing
  const [currentTab, setCurrentTab] = useState<number>(0);
  const [loading, setLoading] = useState<boolean>(false);
  const [transactions, setTransactions] = useState<Transaction[]>([]);
  const [createDialogOpen, setCreateDialogOpen] = useState<boolean>(false);
  const [claimDialogOpen, setClaimDialogOpen] = useState<boolean>(false);
  const [selectedTx, setSelectedTx] = useState<Transaction | null>(null);
  const [crossDAOMode, setCrossDAOMode] = useState<boolean>(false);
  /*const [snackbar, setSnackbar] = useState<SnackbarState>({
    open: false,
    message: '',
    severity: 'success'
  });*/

  const [newTxForm, setNewTxForm] = useState<TransactionForm>({
    recipient: '',
    amount: '',
    condition: '',
    publicKey: ''
  });

  const [claimForm, setClaimForm] = useState<ClaimForm>({
    signature: '',
    condition: ''
  });

  const [snackbar, setSnackbar] = useState<SnackbarState>({
    open: false,
    message: '',
    severity: 'info'
  });
  
  const { web3State, contractService } = useWeb3Manager();
  //const [loading, setLoading] = useState(false);
  //const [transactions, setTransactions] = useState<AnonymousTransaction[]>([]);
  //const [selectedTx, setSelectedTx] = useState<AnonymousTransaction | null>(null);
  //const [createDialogOpen, setCreateDialogOpen] = useState(false);
  //const [claimDialogOpen, setClaimDialogOpen] = useState(false);
  //const [crossDAOMode, setCrossDAOMode] = useState(false);

  // Generic function to handle form field changes
  /*function handleFormChange<T extends TransactionForm | ClaimForm>(
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>,
    setter: React.Dispatch<React.SetStateAction<T>>,
    field: keyof T
  ) {
    setter(prev => ({
      ...prev,
      [field]: e.target.value
    }));
  }*/

useEffect(() => {
  if (!contractService) {
    console.error("[AnonymousTransactions] Contract service not initialized.");
  }

  if (!!contractService) {
    console.error("[AnonymousTransactions] Contract service initialized.");
  }
}, []);

  const handleFormChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>,
    form: 'new' | 'claim'
  ) => {
    const { name, value } = e.target;
    if (form === 'new') {
      setNewTxForm(prev => ({ ...prev, [name]: value }));
    } else {
      setClaimForm(prev => ({ ...prev, [name]: value }));
    }
  };

useEffect(() => {
  const loadTransactions = async () => {
    if (!contractService?.daoToken) return;

    try {
      setLoading(true);
      const filter = contractService.daoToken.filters.AnonymousTransaction();
      const events = await contractService.daoToken.queryFilter(filter);
      
      const txs = await Promise.all(events.map(async (event) => {
        const typedEvent = event as unknown as AnonymousTransactionEvent;
        if (!typedEvent.args) {
          throw new Error('Invalid event format');
        }

        const tx = await contractService.daoToken.anonymousTransactions(typedEvent.args.txHash);
        
        // Transform the contract data into our UI's Transaction type
        // by adding the 'condition' field derived from conditionHash
        const transformedTx: Transaction = {
          ...tx,
          txHash: typedEvent.args.txHash,
          // We need to store the original condition hash but also provide a human-readable condition
          condition: `Condition for ${typedEvent.args.txHash.slice(0, 8)}...`,
          // Keep other required fields from AnonymousTransaction
          publicKeyHash: tx.publicKeyHash,
          conditionHash: tx.conditionHash
        };

        return transformedTx;
      }));

      setTransactions(txs);
    } catch (error) {
      console.error('Error loading transactions:', error);
      showError('Failed to load transactions');
    } finally {
      setLoading(false);
    }
  };

  loadTransactions();
}, [contractService?.daoToken]);

  const showError = (message: string) => {
    setSnackbar({
      open: true,
      message,
      severity: 'error'
    });
  };

  const showSuccess = (message: string) => {
    setSnackbar({
      open: true,
      message,
      severity: 'success'
    });
  };

  // Event handlers with proper typing
  const handleTabChange = (_event: React.SyntheticEvent, newValue: number) => {
    setCurrentTab(newValue);
  };

  const handleCreateTransaction = async () => {
    if (!contractService?.daoToken || !web3State.account) return;

    setLoading(true);
    try {
      if (!integrationContext?.powerDomain) {
        throw new Error('Power Domain access required');
      }

      const publicKeyHash = ethers.utils.keccak256(
        ethers.utils.toUtf8Bytes(newTxForm.publicKey)
      );
      
      const conditionHash = ethers.utils.keccak256(
        ethers.utils.toUtf8Bytes(newTxForm.condition)
      );

      const tx = await contractService.daoToken.createAnonymousTransaction(
        publicKeyHash,
        newTxForm.recipient,
        ethers.utils.parseEther(newTxForm.amount),
        conditionHash
      );

      await tx.wait();
      
      showSuccess('Transaction created successfully');
      setCreateDialogOpen(false);
      
      // Reset form
      setNewTxForm({
        recipient: '',
        amount: '',
        condition: '',
        publicKey: ''
      });

    } catch (error) {
      console.error('Error creating transaction:', error);
      showError(error instanceof Error ? error.message : 'Failed to create transaction');
    } finally {
      setLoading(false);
    }
  };

// Update the handleClaimTransaction function signature to accept Transaction type
const handleClaimTransaction = async (tx: Transaction) => {
  if (!contractService?.daoToken || !tx.txHash) return;

  setLoading(true);
  try {
    const claimTx = await contractService.daoToken.claimAnonymousTransaction(
      tx.txHash,
      claimForm.signature,
      ethers.utils.toUtf8Bytes(claimForm.condition)
    );

    await claimTx.wait();

    showSuccess('Transaction claimed successfully');
    setClaimDialogOpen(false);
    setClaimForm({ signature: '', condition: '' });

    // Update local state
    setTransactions(prev => 
      prev.map(t => 
        t.txHash === tx.txHash ? { ...t, claimed: true } : t
      )
    );

  } catch (error) {
    console.error('Error claiming transaction:', error);
    showError('Failed to claim transaction');
  } finally {
    setLoading(false);
  }
};

  return (
    <Card>
      <CardContent>
        <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 2 }}>
          <Tabs value={currentTab} onChange={handleTabChange}>
            <Tab label="Transactions" />
            <Tab label="Create New" />
          </Tabs>
        </Box>

        {currentTab === 0 && (
          <Box>
            <Paper sx={{ overflow: 'auto' }}>
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell>Transaction Hash</TableCell>
                    <TableCell>Recipient</TableCell>
                    <TableCell>Amount</TableCell>
                    <TableCell>Created</TableCell>
                    <TableCell>Status</TableCell>
                    <TableCell>Actions</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {transactions.map((tx) => (
                    <TableRow key={tx.txHash}>
                      <TableCell>{tx.txHash}</TableCell>
                      <TableCell>{tx.recipient}</TableCell>
                      <TableCell>{ethers.utils.formatEther(tx.amount)} PITA</TableCell>
                      <TableCell>
                        {new Date(tx.creationTime).toLocaleDateString()}
                      </TableCell>
                      <TableCell>
                        <Alert severity={tx.claimed ? "success" : "info"} sx={{ py: 0 }}>
                          {tx.claimed ? 'Claimed' : 'Pending'}
                        </Alert>
                      </TableCell>
                      <TableCell>
                        {!tx.claimed && (
                          <Button
                            variant="outlined"
                            onClick={() => {
                              setSelectedTx(tx);
                              setClaimDialogOpen(true);
                            }}
                          >
                            Claim
                          </Button>
                        )}
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </Paper>
          </Box>
        )}

        {currentTab === 1 && (
          <Box sx={{ mt: 2 }}>
            <Stack spacing={3}>
              <Typography variant="subtitle1">
                Create New Anonymous Transaction
              </Typography>

              <TextField
                label="Recipient Address"
                value={newTxForm.recipient}
                onChange={(e) => handleFormChange(e, 'new')}
                fullWidth
              />

              <TextField
                label="Amount (PITA)"
                type="number"
                value={newTxForm.amount}
                onChange={(e) => handleFormChange(e, 'new')}
                fullWidth
              />

              <TextField
                label="Condition (Optional)"
                value={newTxForm.condition}
                onChange={(e) => handleFormChange(e, 'new')}
                multiline
                rows={2}
                fullWidth
                helperText="Add conditions for claiming this transaction"
              />

              <Button
                variant="contained"
                onClick={handleCreateTransaction}
                disabled={loading || !newTxForm.recipient || !newTxForm.amount}
              >
                {loading ? (
                  <CircularProgress size={24} />
                ) : (
                  'Create Anonymous Transaction'
                )}
              </Button>
            </Stack>
          </Box>
        )}

        <Dialog
          open={claimDialogOpen}
          onClose={() => setClaimDialogOpen(false)}
        >
          <DialogTitle>Claim Anonymous Transaction</DialogTitle>
          <DialogContent>
            <Stack spacing={3} sx={{ mt: 2, minWidth: 400 }}>
              <TextField
                label="Signature"
                value={claimForm.signature}
                onChange={(e) => handleFormChange(e, 'claim')}
                fullWidth
                required
              />

<TextField
  label="Condition Data"
  value={claimForm.condition}
  onChange={(e) => handleFormChange(e, 'claim')}  // Remove the third argument
  multiline
  rows={2}
  fullWidth
  required
/>
            </Stack>
          </DialogContent>
          <DialogActions>
            <Button
              onClick={() => setClaimDialogOpen(false)}
              disabled={loading}
            >
              Cancel
            </Button>
            <Button
              variant="contained"
              onClick={() => selectedTx && handleClaimTransaction(selectedTx)}
              disabled={loading || !claimForm.signature}
            >
              {loading ? (
                <CircularProgress size={24} />
              ) : (
                'Claim Transaction'
              )}
            </Button>
          </DialogActions>
        </Dialog>

        <Snackbar
          open={snackbar.open}
          autoHideDuration={6000}
          onClose={() => setSnackbar(prev => ({ ...prev, open: false }))}
        >
          <Alert
            onClose={() => setSnackbar(prev => ({ ...prev, open: false }))}
            severity={snackbar.severity}
          >
            {snackbar.message}
          </Alert>
        </Snackbar>

        {integrationContext?.powerDomain && (
          <Box sx={{ mt: 2 }}>
            <FormControlLabel
              control={
                <Switch
                  checked={crossDAOMode}
                  onChange={(e) => setCrossDAOMode(e.target.checked)}
                  disabled={!integrationContext.crossDAOEnabled}
                />
              }
              label="Cross-DAO Transaction"
            />
            {crossDAOMode && (
              <Alert severity="info" sx={{ mt: 1 }}>
                Transaction will be routed through integration layer
              </Alert>
            )}
          </Box>
        )}
      </CardContent>
    </Card>
  );
};

export default AnonymousTransactions;
=== ./ProposalList.tsx ===
// src/views/components/dashboard/ProposalList.tsx
import React, { useEffect, useState } from 'react';
import { 
  List,
  ListItem,
  ListItemText,
  Paper,
  Typography,
  ListProps,
  CircularProgress,
  Box
} from '@mui/material';
import { useProposals } from 'contexts/ProposalContext';
import { useWeb3Manager } from 'hooks/useWeb3Manager';
import { ProposalIntegrationService } from './ProposalIntegrationService';
import { Proposal } from 'types/contracts';
import type { ProposalState } from 'types/contracts';
import { ethers, BigNumber } from 'ethers';

// Helper to safely convert various number types to BigNumber
const toBigNumber = (value: number | string | BigNumber | undefined): BigNumber => {
  if (!value) return BigNumber.from(0);
  if (BigNumber.isBigNumber(value)) return value;
  try {
    return BigNumber.from(value.toString());
  } catch {
    return BigNumber.from(0);
  }
};

// Helper to safely get a proposal state
const getProposalState = (state: any): ProposalState => {
  if (typeof state === 'string' && Object.values(ProposalState).includes(state as ProposalState)) {
    return state as ProposalState;
  }
  return ProposalState.DRAFT;
};

// Helper function to normalize any proposal-like object to a proper Proposal
const normalizeProposal = (input: any): Proposal => {
  // Ensure we have an object to work with
  const proposal = input || {};
  
  return {
    // Basic string fields
    id: proposal.id?.toString() || '',
    creator: proposal.creator?.toString() || '',
    title: proposal.title?.toString() || '',
    description: proposal.description?.toString() || '',
    category: Number(proposal.category) || 0,
    
    // Optional string fields
    nostrEventId: proposal.nostrEventId?.toString(),
    nostrPubkey: proposal.nostrPubkey?.toString(),
    submissionTx: proposal.submissionTx?.toString(),
    executionTx: proposal.executionTx?.toString(),
    cancelTx: proposal.cancelTx?.toString(),
    
    // Timestamp field
    createdAt: Number(proposal.createdAt) || Math.floor(Date.now() / 1000),
    
    // BigNumber fields with safe conversion
    startEpoch: toBigNumber(proposal.startEpoch),
    endEpoch: toBigNumber(proposal.endEpoch),
    executionDelay: toBigNumber(proposal.executionDelay),
    forVotes: toBigNumber(proposal.forVotes),
    againstVotes: toBigNumber(proposal.againstVotes),
    quorum: toBigNumber(proposal.quorum),
    
    // Enum field with safe conversion
    currentState: getProposalState(proposal.currentState)
  };
};

interface ProposalListProps extends Omit<ListProps, 'children'> {
  proposals?: any[];
  domainWeight?: number;
}

const ProposalList: React.FC<ProposalListProps> = ({ 
  proposals: initialProposals, 
  domainWeight, 
  className, 
  ...props 
}) => {
  const [loading, setLoading] = useState(true);
  const [proposals, setProposals] = useState<Proposal[]>([]);
  const { activeProposals } = useProposals();
  const { contractService } = useWeb3Manager();

useEffect(() => {
  if (!contractService) {
    console.error("[ProposalList] Contract service not initialized.");
  }

  if (!!contractService) {
    console.error("[ProposalList] Contract service initialized.");
  }
}, []);

  useEffect(() => {
    const loadProposals = async () => {
      if (!contractService) return;

      try {
        setLoading(true);
        const integrationService = new ProposalIntegrationService(contractService);
        const fetchedProposals = await integrationService.getAllProposals();
        
        // Normalize all proposals from different sources
        const allProposals = [
          ...(initialProposals || []).map(normalizeProposal),
          ...fetchedProposals.map(normalizeProposal),
          ...(activeProposals || []).map(normalizeProposal)
        ];

        // Remove duplicates based on proposal ID
        const uniqueProposals = Array.from(
          new Map(allProposals.map(p => [p.id, p])).values()
        );

        setProposals(uniqueProposals);
      } catch (error) {
        console.error('Error loading proposals:', error);
      } finally {
        setLoading(false);
      }
    };

    loadProposals();
  }, [contractService, initialProposals, activeProposals]);

  // Component render logic...
  if (loading) {
    return (
      <Box display="flex" justifyContent="center" p={3}>
        <CircularProgress />
      </Box>
    );
  }

  if (proposals.length === 0) {
    return (
      <Paper sx={{ p: 2 }}>
        <Typography color="text.secondary">
          No active proposals
        </Typography>
      </Paper>
    );
  }

  return (
    <List className={className} {...props}>
      {proposals.map(proposal => (
        <ListItem key={proposal.id}>
          <ListItemText
            primary={proposal.title}
            secondary={
              <Box>
                <Typography variant="body2" color="text.secondary">
                  {proposal.description}
                </Typography>
                <Typography variant="caption" color="text.secondary">
                  ID: {proposal.id} • Weight: {domainWeight || 1}x • 
                  State: {proposal.currentState}
                </Typography>
              </Box>
            }
          />
        </ListItem>
      ))}
    </List>
  );
};

export default ProposalList;
=== ./MembershipStats.tsx ===
// Main App: views/components/dashboard/MembershipStats.tsx

import React, { useEffect, useState } from 'react';
import { ContractService } from './contractService';
import { ethers } from 'ethers';
import { 
  Card,
  CardHeader,
  CardContent,
  Typography,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  Paper,
  CircularProgress,
  Box
} from '@mui/material';

import {
  PieChart,
  Pie,
  Cell,
  ResponsiveContainer,
  Tooltip
} from 'recharts';

import { LineChart, Line, XAxis, YAxis, CartesianGrid } from 'recharts';
import { Users, Vote, Wallet, Share2 } from 'lucide-react';

// Type definitions for the component's data structures
interface MemberCategory {
  name: string;
  value: number;
  color: string;
}

interface RecentMember {
  address: string;
  joinDate: number;
  biddingShares: number;
}

// Enhanced type definitions to include connection data
interface Connection {
  target: string;
  trustScore: number;
  isFamilial: boolean;
  isInstitutional: boolean;
}

interface ConnectionResponse {
  target: string;
  trustScore: ethers.BigNumber;
  isFamilial: boolean;
  isInstitutional: boolean;
}

interface MemberConnectionStats {
  totalConnections: number;
  averageTrustScore: number;
  familialConnections: number;
  institutionalConnections: number;
  connectionsList: Connection[];
}

interface MembershipData {
  totalMembers: number;
  activeMembersLast30Days: number;
  averageParticipation: number;
  recentMembers: RecentMember[];
  memberCategories: MemberCategory[];
  connectionStats: MemberConnectionStats;
}

const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042'] as const;

const initialMembershipData: MembershipData = {
  totalMembers: 0,
  activeMembersLast30Days: 0,
  averageParticipation: 0,
  recentMembers: [],
  memberCategories: [],
  connectionStats: {
    totalConnections: 0,
    averageTrustScore: 0,
    familialConnections: 0,
    institutionalConnections: 0,
    connectionsList: []
  }
};

const MembershipStats: React.FC = () => {
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
const [membershipData, setMembershipData] = useState<MembershipData>(initialMembershipData);

useEffect(() => {
  const fetchMembershipData = async () => {
    try {
      setLoading(true);
      
      // Check for ethereum provider first
      const ethereum = window.ethereum;
      if (!ethereum) {
        throw new Error('No Ethereum provider found');
      }
      
      const provider = new ethers.providers.Web3Provider(ethereum);
      const contractService = new ContractService(
        provider,
        '0x23767A0C9A072C6A081C27A1C03Cc95B9F9cc6E0'
      );

      // Fetch basic membership data
      const currentTimestamp = Math.floor(Date.now() / 1000);
      const thirtyDaysAgo = currentTimestamp - (30 * 24 * 60 * 60);
      let activeCount = 0;
      const recentMembers: RecentMember[] = [];

      const activeUserCount = await contractService.daoToken.activeUserCount();
      const activeUserCountNumber = activeUserCount.toNumber();

      // Get membership details for each user
      for(let i = 0; i < activeUserCountNumber; i++) {
        const address = await contractService.contract.activeUserIndex(i);
        const memberStatus = await contractService.getMembershipStatus(address);
        
        if(memberStatus.lastActivity > thirtyDaysAgo) {
          activeCount++;
        }

        if(memberStatus.lastActivity > currentTimestamp - (7 * 24 * 60 * 60)) {
          recentMembers.push({
            address,
            joinDate: memberStatus.lastActivity,
            biddingShares: memberStatus.biddingShares
          });
        }
      }

      const participationRate = activeUserCountNumber > 0 
        ? (activeCount / activeUserCountNumber) * 100 
        : 0;

      // Fetch connection data in batches to avoid rate limiting
      const BATCH_SIZE = 10;
      const MAX_BATCHES = 10;
      const signer = provider.getSigner();
      const userAddress = await signer.getAddress();
      
      let connections: Connection[] = [];
      let totalTrustScore = 0;
      let familialCount = 0;
      let institutionalCount = 0;

      // Fetch connections in smaller batches with delays
      for (let batch = 0; batch < MAX_BATCHES; batch++) {
        const batchStart = batch * BATCH_SIZE;
        
        // Add delay between batches to prevent rate limiting
        if (batch > 0) {
          await new Promise(resolve => setTimeout(resolve, 500));
        }

        const batchPromises = Array.from({ length: BATCH_SIZE }).map(async (_, i) => {
          try {
            const index = batchStart + i;
            return await contractService.contract.connections(userAddress, index);
          } catch {
            return null;
          }
        });

        const batchResults = await Promise.all(batchPromises);
        const validBatchConnections = batchResults.filter((conn): conn is ConnectionResponse => 
          conn !== null && conn.target !== ethers.constants.AddressZero
        );

        // Stop if no valid connections in this batch
        if (validBatchConnections.length === 0) {
          break;
        }

        // Process valid connections
        validBatchConnections.forEach(connection => {
          connections.push({
            target: connection.target,
            trustScore: connection.trustScore.toNumber(),
            isFamilial: connection.isFamilial,
            isInstitutional: connection.isInstitutional
          });
          
          totalTrustScore += connection.trustScore.toNumber();
          if (connection.isFamilial) familialCount++;
          if (connection.isInstitutional) institutionalCount++;
        });
      }

      // Update state with all collected data
      setMembershipData({
        totalMembers: activeUserCountNumber,
        activeMembersLast30Days: activeCount,
        averageParticipation: participationRate,
        recentMembers,
        memberCategories: [
          { 
            name: 'Regular Members', 
            value: activeUserCountNumber - activeCount,
            color: COLORS[0]
          },
          { 
            name: 'Active Members', 
            value: activeCount,
            color: COLORS[1]
          }
        ],
        connectionStats: {
          totalConnections: connections.length,
          averageTrustScore: connections.length > 0 ? totalTrustScore / connections.length : 0,
          familialConnections: familialCount,
          institutionalConnections: institutionalCount,
          connectionsList: connections
        }
      });

      setLoading(false);
    } catch (error: unknown) {
      // First, check if the error is an object with a message property
      if (
        error && 
        typeof error === 'object' && 
        'message' in error && 
        typeof error.message === 'string'
      ) {
        // Now TypeScript knows error.message is a string
        if (error.message.includes('Request limit exceeded')) {
          console.warn('MetaMask request limit reached. Some connection data may be incomplete.');
          setError('Some data may be incomplete due to rate limiting. Please try again in a moment.');
        } else {
          setError(error.message);
        }
      } else {
        // Handle cases where error isn't an Error object
        setError('An unknown error occurred');
      }
      console.error('Error fetching membership data:', error);
      setLoading(false);
    }
  };

  fetchMembershipData();
  const interval = setInterval(fetchMembershipData, 300000);
  return () => clearInterval(interval);
}, []);

const ConnectionStatsCard = () => (
  <Box sx={{ mt: 4 }}>
    <Typography variant="h6" sx={{ mb: 2 }}>
      <Box sx={{ display: 'flex', alignItems: 'center' }}>
        <Share2 className="mr-2" size={20} />
        Connection Statistics
      </Box>
    </Typography>
    
    <Box sx={{ 
      display: 'grid', 
      gridTemplateColumns: { xs: 'repeat(2, 1fr)', md: 'repeat(4, 1fr)' }, 
      gap: 2,
      mb: 4 
    }}>
      <Paper sx={{ p: 2 }}>
        <Typography variant="body2" color="text.secondary">
          Total Connections
        </Typography>
        <Typography variant="h6">
          {membershipData.connectionStats.totalConnections}
        </Typography>
      </Paper>
      
      <Paper sx={{ p: 2 }}>
        <Typography variant="body2" color="text.secondary">
          Avg Trust Score
        </Typography>
        <Typography variant="h6">
          {membershipData.connectionStats.averageTrustScore.toFixed(1)}
        </Typography>
      </Paper>
      
      <Paper sx={{ p: 2 }}>
        <Typography variant="body2" color="text.secondary">
          Familial
        </Typography>
        <Typography variant="h6">
          {membershipData.connectionStats.familialConnections}
        </Typography>
      </Paper>
      
      <Paper sx={{ p: 2 }}>
        <Typography variant="body2" color="text.secondary">
          Institutional
        </Typography>
        <Typography variant="h6">
          {membershipData.connectionStats.institutionalConnections}
        </Typography>
      </Paper>
    </Box>

    <Paper sx={{ width: '100%', overflow: 'auto' }}>
      <Table>
        <TableHead>
          <TableRow>
            <TableCell>Connected Address</TableCell>
            <TableCell>Trust Score</TableCell>
            <TableCell>Type</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {membershipData.connectionStats.connectionsList.map((connection, index) => (
            <TableRow key={index}>
              <TableCell>
                {`${connection.target.slice(0, 6)}...${connection.target.slice(-4)}`}
              </TableCell>
              <TableCell>{connection.trustScore}</TableCell>
              <TableCell>
                {connection.isFamilial ? 'Familial' : 
                 connection.isInstitutional ? 'Institutional' : 'Standard'}
              </TableCell>
            </TableRow>
          ))}
          {membershipData.connectionStats.connectionsList.length === 0 && (
            <TableRow>
              <TableCell colSpan={3} align="center">
                <Typography color="text.secondary">No connections found</Typography>
              </TableCell>
            </TableRow>
          )}
        </TableBody>
      </Table>
    </Paper>
  </Box>
);

  if (loading) {
    return (
      <Card>
        <CardHeader title="Membership Statistics" />
        <CardContent>
          <Box display="flex" justifyContent="center" alignItems="center" minHeight={200}>
            <CircularProgress />
          </Box>
        </CardContent>
      </Card>
    );
  }

  if (error) {
    return (
      <Card>
        <CardHeader title="Membership Statistics" />
        <CardContent>
          <Typography color="error">{error}</Typography>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader title="Membership Statistics" />
      <CardContent>
        {/* Overview Stats */}
        <Box sx={{ 
          display: 'grid', 
          gridTemplateColumns: 'repeat(3, 1fr)', 
          gap: 2,
          mb: 4 
        }}>
          <Box>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
              <Users className="mr-2" size={20} />
              <Typography variant="body2" color="text.secondary">
                Total Members
              </Typography>
            </Box>
            <Typography variant="h4">
              {membershipData.totalMembers.toLocaleString()}
            </Typography>
          </Box>

          <Box>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
              <Vote className="mr-2" size={20} />
              <Typography variant="body2" color="text.secondary">
                Active (30d)
              </Typography>
            </Box>
            <Typography variant="h4">
              {membershipData.activeMembersLast30Days.toLocaleString()}
            </Typography>
          </Box>

          <Box>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
              <Wallet className="mr-2" size={20} />
              <Typography variant="body2" color="text.secondary">
                Participation
              </Typography>
            </Box>
            <Typography variant="h4">
              {membershipData.averageParticipation.toFixed(1)}%
            </Typography>
          </Box>
        </Box>

        {/* Member Categories Pie Chart */}
        <Box sx={{ height: 300, mb: 4 }}>
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <Pie
                data={membershipData.memberCategories}
                dataKey="value"
                nameKey="name"
                cx="50%"
                cy="50%"
                outerRadius={80}
                label
              >
                {membershipData.memberCategories.map((entry, index) => (
                  <Cell key={`cell-${index}`} fill={entry.color} />
                ))}
              </Pie>
              <Tooltip />
            </PieChart>
          </ResponsiveContainer>
        </Box>

        {/* Recent Members Table */}
        <Box>
          <Typography variant="h6" sx={{ mb: 2 }}>Recent Members</Typography>
          <Paper sx={{ width: '100%', overflow: 'hidden' }}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Address</TableCell>
                  <TableCell>Joined</TableCell>
                  <TableCell>Bidding Shares</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {membershipData.recentMembers.map((member) => (
                  <TableRow key={member.address}>
                    <TableCell>{member.address}</TableCell>
                    <TableCell>
                      {new Date(member.joinDate * 1000).toLocaleDateString()}
                    </TableCell>
                    <TableCell>{member.biddingShares}%</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </Paper>
        </Box>
      <ConnectionStatsCard />
      </CardContent>
    </Card>
  );
};

// Add type declaration for window.ethereum
declare global {
  interface Window {
    ethereum?: ethers.providers.ExternalProvider;
  }
}

export default MembershipStats;
=== ./DomainMonitor.tsx ===
// Main App: src/views/components/dashboard/DomainMonitor.tsx
import React, { useState, useEffect } from 'react';
import { 
  Card, 
  CardContent, 
  Typography, 
  Box, 
  LinearProgress,
  Chip,
  Grid
} from '@mui/material';
import { Shield, Check, AlertCircle } from 'lucide-react';
import { useWeb3Manager } from '../../../hooks/useWeb3Manager';

interface DomainMetrics {
  currentLevel: number;    // 16.67-25.00
  stage: number;          // From StateConstituent
  governanceWeight: number;
  capabilities: {
    daoStructure: boolean;    // >= 17.59
    complexGovernance: boolean; // >= 20.37
    sovereignAuthority: boolean; // >= 23.15
  };
}

const DomainMonitor: React.FC = () => {
  const [metrics, setMetrics] = useState<DomainMetrics>();
  const { contractService } = useWeb3Manager();

useEffect(() => {
  if (!contractService) {
    console.error("[DomainMonitor] Contract service not initialized.");
  }

  if (!!contractService) {
    console.error("[DomainMonitor] Contract service initialized.");
  }
}, []);

  useEffect(() => {
    const loadMetrics = async () => {
      if (!contractService) {
        console.error('[DomainMonitor] Contract service not initialized');
        return;
      } else {
        console.log('[DomainMonitor] Contract service initialized. Continuing...');
      }

      try {
        const stateData = await contractService.getProposalState(
          0
        );

        const stage = stateData.data.stage || 0;
        //const stage = stateData.data.stage?.toNumber() || 0;
        const currentLevel = stage >= 3 ? 
          16.67 + (stage - 3) * 1.85185185 : 
          16.67;

        setMetrics({
          currentLevel,
          stage: stage,
          governanceWeight: Math.floor((currentLevel - 16.67) * 10) / 10 + 1,
          capabilities: {
            daoStructure: currentLevel >= 17.59259259,
            complexGovernance: currentLevel >= 20.37037037,
            sovereignAuthority: currentLevel >= 23.14814815
          }
        });
      } catch (error) {
        console.error('[DomainMonitor] Failed to load domain metrics:', error);
      }
    };

    loadMetrics();
    const interval = setInterval(loadMetrics, 30000);
    return () => clearInterval(interval);
  }, [contractService]);

  if (!metrics) {
    return (
      <Card>
        <CardContent>
          <Box display="flex" justifyContent="center" alignItems="center" minHeight={200}>
            <Typography>Loading domain status...</Typography>
          </Box>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardContent>
        <Box display="flex" alignItems="center" mb={2}>
          <Shield className="h-5 w-5 mr-2" />
          <Typography variant="h6">Domain Status</Typography>
        </Box>

        <Box mb={3}>
          <Typography variant="body2" color="textSecondary" gutterBottom>
            Domain Level Progress
          </Typography>
          <Box display="flex" alignItems="center" mb={1}>
            <Typography variant="h4" component="span">
              {metrics.currentLevel.toFixed(8)}
            </Typography>
            <Typography variant="body2" color="textSecondary" ml={1}>
              / 25.00
            </Typography>
          </Box>
          <LinearProgress 
            variant="determinate" 
            value={((metrics.currentLevel - 16.67) / (25 - 16.67)) * 100}
            sx={{ height: 8, borderRadius: 1 }}
          />
        </Box>

        <Grid container spacing={2} mb={3}>
          <Grid item xs={6}>
            <Typography variant="body2" color="textSecondary" gutterBottom>
              Stage
            </Typography>
            <Typography variant="h6">
              {metrics.stage}
            </Typography>
          </Grid>
          <Grid item xs={6}>
            <Typography variant="body2" color="textSecondary" gutterBottom>
              Governance Weight
            </Typography>
            <Typography variant="h6">
              {metrics.governanceWeight}x
            </Typography>
          </Grid>
        </Grid>

        <Typography variant="body2" color="textSecondary" gutterBottom>
          Available Capabilities
        </Typography>
        <Box display="flex" flexWrap="wrap" gap={1}>
          {Object.entries(metrics.capabilities).map(([key, enabled]) => (
            <Chip
              key={key}
              label={formatCapability(key)}
              icon={enabled ? <Check /> : <AlertCircle />}
              color={enabled ? "primary" : "default"}
              variant={enabled ? "filled" : "outlined"}
            />
          ))}
        </Box>
      </CardContent>
    </Card>
  );
};

const formatCapability = (key: string): string => {
  switch (key) {
    case 'daoStructure': return 'DAO Structure';
    case 'complexGovernance': return 'Complex Governance';
    case 'sovereignAuthority': return 'Sovereign Authority';
    default: return key;
  }
};

export default DomainMonitor;
=== ./ProposalTypes.ts ===
// src/views/components/dashboard/ProposalTypes.ts
import { ethers, BigNumber } from 'ethers';
import { ProposalState } from 'types/contracts';

// Export the DAO proposal interface that matches the contract types
export interface DAOProposal {
  id: string;
  title: string;
  description: string;
  proposer?: string;
  creator: string;
  startTime: number;
  endTime: number;
  forVotes: BigNumber;
  againstVotes: BigNumber;
  executed: boolean;
  category: number;
  startEpoch: BigNumber;
  endEpoch: BigNumber;
  executionDelay: BigNumber;
  currentState: ProposalState;
  quorum: BigNumber;
  createdAt: number;
}

// Export service interfaces
export interface VoteResult {
  forVotes: BigNumber;
  againstVotes: BigNumber;
}

export interface ProposalCreation {
  title: string;
  description: string;
  category: number;
  votingPeriod: number;
}
=== ./StateProgression.tsx ===
// Main App: src/views/components/dashboard/StateProgression.tsx

import React, { useEffect, useCallback } from 'react';
import { 
  Card,
  CardContent,
  CardHeader,
  Typography,
  LinearProgress,
  Chip,
  Button,
  Box,
  FormLabel
} from '@mui/material';
import CircularProgress from '@mui/material/CircularProgress';

// Import service types
import { 
  SystemState as ServiceSystemState,
  FoundationState as ServiceFoundationState 
} from '../../../services/StateTransitionService';

// Import UI types
import { 
  SystemState as UISystemState,
  TransitionRequirements,
  Capability 
} from '../../../types/transition';

// Custom hooks
import { useStateTransition } from '../../../hooks/useStateTransition';
import { useTransitionRequirements } from '../../../hooks/useTransitionRequirements';

// Utility functions
import { getLayerName, calculateProgress } from '../../../util/stateUtils';

// Components
import { RequirementDisplay } from '../../../components/RequirementDisplay';

interface StateProgressionProps {
  address: string;
}

// Helper function to format capability names for display
const formatCapability = (capability: Capability): string => {
  const formattingMap: { [key: string]: string } = {
    daoStructure: 'DAO Structure',
    complexGovernance: 'Complex Governance',
    sovereignAuthority: 'Sovereign Authority',
    BASIC_RIGHTS: 'Basic Rights',
    INTERMEDIATE_RIGHTS: 'Intermediate Rights',
    FORMATION_COMPLETE: 'Formation Complete'
  };
  
  return formattingMap[capability.type] || capability.type;
};

// Adapter function to transform service state to UI state
const adaptServiceStateToUIState = (state: ServiceSystemState): UISystemState => {
  // Check if state is a FoundationState
  const capabilities = (state as ServiceFoundationState).capabilities || [];

  return {
    ...state,
    capabilities: capabilities.map(capType => ({
      type: capType,
      active: true,
      description: ''  // Add description if available from the service
    }))
  };
};

export const StateProgression: React.FC<StateProgressionProps> = ({ address }) => {
  const { 
    currentState: serviceState, 
    loading: stateLoading, 
    error: stateError,
    executeTransition 
  } = useStateTransition(address);

  // Transform service state to UI state
  const currentState = serviceState ? adaptServiceStateToUIState(serviceState) : null;

  const {
    transitionRequirements,
    loading: requirementsLoading,
    error: requirementsError,
    checkTransitionRequirements
  } = useTransitionRequirements(address, currentState);

  const handleTransition = useCallback(async () => {
    if (!transitionRequirements?.nextState) return;
    
    try {
      await executeTransition(transitionRequirements.nextState);
    } catch (error) {
      console.error('Failed to execute transition:', error);
    }
  }, [executeTransition, transitionRequirements]);

  useEffect(() => {
    if (currentState) {
      checkTransitionRequirements();
    }
  }, [currentState, checkTransitionRequirements]);

  if (stateLoading || requirementsLoading) {
    return (
      <Box display="flex" justifyContent="center" p={3}>
        <CircularProgress />
      </Box>
    );
  }

  if (!currentState) {
    return null;
  }

  const error = stateError || requirementsError;
  if (error) {
    return (
      <Box p={3}>
        <Typography color="error">
          Error: {error.message}
        </Typography>
      </Box>
    );
  }

  return (
    <Card>
      <CardHeader 
        title={
          <Typography variant="h6">System State</Typography>
        }
      />
      <CardContent>
        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
          {/* Current State Display */}
          <Box>
            <FormLabel>Current Level</FormLabel>
            <Typography variant="h4">
              {currentState.level.toFixed(8)}
            </Typography>
            <Typography variant="body2" color="text.secondary">
              {getLayerName(currentState.level)}
            </Typography>
          </Box>

          {/* Progress to Next State */}
          <Box>
            <FormLabel>Progress to Next State</FormLabel>
            <LinearProgress 
              variant="determinate"
              value={calculateProgress(currentState, transitionRequirements || undefined)}
              sx={{ mt: 1 }}
            />
          </Box>

          {/* Capabilities */}
          <Box>
            <FormLabel>Active Capabilities</FormLabel>
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mt: 1 }}>
              {currentState.capabilities.map((cap: Capability) => (
                <Chip 
                  key={cap.type}
                  label={formatCapability(cap)}
                  variant="outlined"
                  color={cap.active ? "primary" : "default"}
                />
              ))}
            </Box>
          </Box>

          {/* Transition Requirements */}
          {transitionRequirements && (
            <Box>
              <FormLabel>Next State Requirements</FormLabel>
              <Box sx={{ mt: 1 }}>
                {transitionRequirements.requirements.map(req => (
                  <RequirementDisplay
                    key={req.type}
                    requirement={req}
                    currentValue={req.currentValue}
                  />
                ))}
              </Box>
            </Box>
          )}

          {/* Transition Controls */}
          {transitionRequirements?.readyForTransition && (
            <Button
              variant="contained"
              fullWidth
              onClick={handleTransition}
            >
              Progress to Next State
            </Button>
          )}
        </Box>
      </CardContent>
    </Card>
  );
};
=== ./DAOGovernance.tsx ===
// Main App: src/views/components/dashboard/DAOGovernance.tsx
import React, { useState, useEffect } from 'react';
import { 
  Card, 
  CardContent, 
  Typography, 
  Box,
  Tabs,
  Tab,
  Button,
  Alert,
  AlertTitle,
  Grid
} from '@mui/material';
import { 
  Settings, 
  Vote, 
  Wallet, 
  Shield, 
  AlertTriangle 
} from 'lucide-react';
import { useWeb3Manager } from 'hooks/useWeb3Manager';

interface GovernanceProps {
  domainLevel: number;
  governanceWeight: number;
  stage: number;
}

const DAOGovernance: React.FC<GovernanceProps> = ({
  domainLevel,
  governanceWeight,
  stage
}) => {
  const [currentTab, setCurrentTab] = useState(0);
  const { contractService } = useWeb3Manager();

useEffect(() => {
  if (!contractService) {
    console.error("[DAOGovernance] Contract service not initialized.");
  }

  if (!!contractService) {
    console.error("[DAOGovernance] Contract service initialized.");
  }
}, []);

  // Helper function to determine available features
  const canAccess = {
    basicStructure: domainLevel >= 17.59259259,
    complexGovernance: domainLevel >= 20.37037037,
    sovereignAuthority: domainLevel >= 23.14814815
  };
  
  // Add a check for contractService availability
  const isServiceReady = Boolean(contractService);

  // Modify button disabled states to account for service availability
  const buttonDisabled = !isServiceReady || !canAccess.basicStructure;

  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setCurrentTab(newValue);
  };

  return (
    <Card>
      <CardContent>
        <Box display="flex" alignItems="center" mb={3}>
          <Vote className="h-5 w-5 mr-2" />
          <Typography variant="h6">Governance Controls</Typography>
        </Box>

        <Tabs
          value={currentTab}
          onChange={handleTabChange}
          variant="scrollable"
          scrollButtons="auto"
          sx={{ mb: 3 }}
        >
          <Tab 
            label="DAO Structure" 
            icon={<Settings className="h-4 w-4" />}
          />
          {canAccess.complexGovernance && (
            <Tab 
              label="Advanced Controls" 
              icon={<Wallet className="h-4 w-4" />}
            />
          )}
          {canAccess.sovereignAuthority && (
            <Tab 
              label="Sovereign Powers" 
              icon={<Shield className="h-4 w-4" />}
            />
          )}
        </Tabs>

        {/* Basic DAO Structure Tab */}
        {currentTab === 0 && (
          <Box>
            <Grid container spacing={2}>
              <Grid item xs={12} md={6}>
                <Card variant="outlined">
                  <CardContent>
                    <Typography variant="subtitle1" gutterBottom>
                      Department Management
                    </Typography>
                    <Button 
                      variant="contained" 
                      fullWidth
                      disabled={buttonDisabled}
                    >
                      Manage Departments
                    </Button>
                  </CardContent>
                </Card>
              </Grid>
              <Grid item xs={12} md={6}>
                <Card variant="outlined">
                  <CardContent>
                    <Typography variant="subtitle1" gutterBottom>
                      Policy Controls
                    </Typography>
                    <Button 
                      variant="contained" 
                      fullWidth
                      disabled={!canAccess.basicStructure}
                    >
                      Update Policies
                    </Button>
                  </CardContent>
                </Card>
              </Grid>
            </Grid>
          </Box>
        )}

        {/* Complex Governance Tab */}
        {currentTab === 1 && canAccess.complexGovernance && (
          <Box>
            <Grid container spacing={2}>
              <Grid item xs={12} md={4}>
                <Card variant="outlined">
                  <CardContent>
                    <Typography variant="subtitle1" gutterBottom>
                      Parameter Control
                    </Typography>
                    <Button 
                      variant="contained" 
                      fullWidth
                    >
                      Modify Parameters
                    </Button>
                  </CardContent>
                </Card>
              </Grid>
              <Grid item xs={12} md={4}>
                <Card variant="outlined">
                  <CardContent>
                    <Typography variant="subtitle1" gutterBottom>
                      Treasury Management
                    </Typography>
                    <Button 
                      variant="contained" 
                      fullWidth
                    >
                      Manage Treasury
                    </Button>
                  </CardContent>
                </Card>
              </Grid>
              <Grid item xs={12} md={4}>
                <Card variant="outlined">
                  <CardContent>
                    <Typography variant="subtitle1" gutterBottom>
                      Veto Rights
                    </Typography>
                    <Button 
                      variant="contained" 
                      fullWidth
                    >
                      Review Proposals
                    </Button>
                  </CardContent>
                </Card>
              </Grid>
            </Grid>
          </Box>
        )}

        {/* Sovereign Authority Tab */}
        {currentTab === 2 && canAccess.sovereignAuthority && (
          <Box>
            <Alert severity="warning" sx={{ mb: 2 }}>
              <AlertTitle>Sovereign Powers Active</AlertTitle>
              These controls have significant impact. Use with caution.
            </Alert>
            <Grid container spacing={2}>
              <Grid item xs={12} md={6}>
                <Card variant="outlined">
                  <CardContent>
                    <Typography variant="subtitle1" gutterBottom>
                      Emergency Controls
                    </Typography>
                    <Button 
                      variant="contained" 
                      color="warning"
                      fullWidth
                      startIcon={<AlertTriangle />}
                    >
                      Emergency Actions
                    </Button>
                  </CardContent>
                </Card>
              </Grid>
              <Grid item xs={12} md={6}>
                <Card variant="outlined">
                  <CardContent>
                    <Typography variant="subtitle1" gutterBottom>
                      Strategic Direction
                    </Typography>
                    <Button 
                      variant="contained" 
                      fullWidth
                    >
                      Set Strategy
                    </Button>
                  </CardContent>
                </Card>
              </Grid>
            </Grid>
          </Box>
        )}
      </CardContent>
    </Card>
  );
};

export default DAOGovernance;
=== ./DAOPage.tsx ===
// Main App: src/views/components/dashboard/DAOPage.tsx
import React, { useState, useEffect } from 'react';
import { useAtom } from 'jotai';
import { 
  Card,
  CardHeader,
  CardContent,
  Alert,
  AlertTitle,
  Typography,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  Paper,
  Tabs,
  Tab,
  Box,
  Stack,
  Chip,
  Button
} from '@mui/material';
import { useNavigate } from '@reach/router';
import { 
  LayoutDashboard,
  Vote,
  Wallet,
  Users,
  Settings
} from 'lucide-react';

import DAODashboard from './DAODashboard';
import ProposalCreation from './ProposalCreation';
import VotingInterface from './VotingInterface';
import TokenMetrics from './TokenMetrics';
import MembershipStats from './MembershipStats';
import AnonymousTransactions from './AnonymousTransactions';
import ProposalDisplay from './ProposalDisplay';
import { isConnectedAtom, accountAtom, chainIdAtom } from '../../../state/web3State';
import DAOProfile from './DAOProfile';
import { ContractService } from './contractService';
import { ethers } from 'ethers';

import AppWrapper from 'views/components/app-wrapper';
import AppMenu from 'views/components/app-menu';

import { BigNumber } from 'ethers';

function TabPanel(props: {
  children?: React.ReactNode;
  value: string;
  index: string;
}) {
  const { children, value, index } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
    >
      {value === index && (
        <Box sx={{ py: 3 }}>
          {children}
        </Box>
      )}
    </div>
  );
}

interface ErrorBoundaryProps {
    children: React.ReactNode;
}

const DAOErrorBoundary: React.FC<ErrorBoundaryProps> = ({ children }) => {
    const [error, setError] = useState<Error | null>(null);

    if (error) {
        return (
            <Alert severity="error" sx={{ m: 2 }}>
                <AlertTitle>DAO Error</AlertTitle>
                {error.message}
                <Button onClick={() => setError(null)} sx={{ mt: 1 }}>
                    Retry
                </Button>
            </Alert>
        );
    }

    return <>{children}</>;
};

const ConnectionStatus = () => {
  const [isConnected] = useAtom(isConnectedAtom);
  
  return (
    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
      <Box sx={{
        width: 10,
        height: 10,
        borderRadius: '50%',
        bgcolor: isConnected ? 'success.main' : 'error.main'
      }} />
      <Typography variant="caption">
        {isConnected ? 'Connected' : 'Disconnected'}
      </Typography>
    </Box>
  );
};

const DAOPage: React.FC = () => {
  const [currentTab, setCurrentTab] = useState('dashboard');
  const [isConnected] = useAtom(isConnectedAtom);
  const [account] = useAtom(accountAtom);
  const [chainId] = useAtom(chainIdAtom);
  const navigate = useNavigate();
  const [contractService, setContractService] = useState<ContractService | null>(null);
  
  const Header = () => (
    <Box sx={{ 
      borderBottom: 1, 
      borderColor: 'divider',
      p: 2,
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center'
    }}>
      <Typography variant="h6">DAO Dashboard</Typography>
      {isConnected ? (
        <Stack direction="row" spacing={2}>
          <Chip
            label={`${account?.slice(0, 6)}...${account?.slice(-4)}`}
            color="success"
            sx={{ borderRadius: 1 }}
          />
          <Chip
            label={`Chain ID: ${chainId}`}
            color="primary"
            sx={{ borderRadius: 1 }}
          />
        </Stack>
      ) : (
        <Button 
          variant="contained"
          onClick={() => navigate('/settings/keys')}
        >
          Connect Wallet
        </Button>
      )}
    </Box>
  );

useEffect(() => {
  const initializeContract = async () => {
    if (!window.ethereum || !isConnected) {
      return;
    }

    try {
      const provider = new ethers.providers.Web3Provider(window.ethereum);
      await provider.send("eth_requestAccounts", []); // Request account access first
      
      const contractServiceInstance = new ContractService(
        provider, 
        '0x23767A0C9A072C6A081C27A1C03Cc95B9F9cc6E0'
      );
      
      // Verify contract connection
      const testCall = await contractServiceInstance.contract.provider;
      if (!testCall) {
        throw new Error('Contract connection failed');
      }
      
      setContractService(contractServiceInstance);
    } catch (error) {
      console.error('Failed to initialize contract service:', error);
    }
  };

  initializeContract();
}, [isConnected]); // Add isConnected as dependency

  const handleTabChange = (_: React.SyntheticEvent, newValue: string) => {
    setCurrentTab(newValue);
  };

useEffect(() => {
  if (!contractService) {
    console.error("[DAOPage] Contract service not initialized.");
  }

  if (!!contractService) {
    console.error("[DAOPage] Contract service initialized.");
  }
}, []);

  return (
      <AppWrapper>
    <AppMenu />
    <Box sx={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
      <Header />

      <Box sx={{ flex: 1, p: 3 }}>
        <Box sx={{ display: 'flex', gap: 3 }}>
          <Box sx={{ width: 240, flexShrink: 0 }}>
            <Tabs
              orientation="vertical"
              value={currentTab}
              onChange={handleTabChange}
              sx={{
                borderRight: 1,
                borderColor: 'divider',
                '& .MuiTab-root': {
                  justifyContent: 'flex-start',
                  textAlign: 'left',
                  alignItems: 'center',
                  gap: 1
                }
              }}
            >
              <Tab 
                icon={<LayoutDashboard />} 
                label="Overview" 
                value="dashboard"
                iconPosition="start"
              />
              <Tab 
                icon={<Vote />} 
                label="Proposals" 
                value="proposals"
                iconPosition="start"
              />
              <Tab 
                icon={<Wallet />} 
                label="Treasury" 
                value="treasury"
                iconPosition="start"
              />
              <Tab 
                icon={<Users />} 
                label="Members" 
                value="members"
                iconPosition="start"
              />
              <Tab 
                icon={<Settings />} 
                label="Settings" 
                value="settings"
                iconPosition="start"
              />
              <Tab 
                label="Anonymous Transactions" 
                value="anontransact"
                iconPosition="start"
              />
            </Tabs>
          </Box>

          <Box sx={{ flex: 1 }}>
            <TabPanel value={currentTab} index="dashboard">
              <DAODashboard />
            </TabPanel>

            <TabPanel value={currentTab} index="proposals">
              <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
                <ProposalCreation />
                {contractService && <ProposalDisplay contractService={contractService} />}
              </Box>
            </TabPanel>

            <TabPanel value={currentTab} index="treasury">
              <TokenMetrics />
            </TabPanel>

            <TabPanel value={currentTab} index="members">
            <DAOErrorBoundary>
              <MembershipStats />
            </DAOErrorBoundary>
            </TabPanel>
            <TabPanel value={currentTab} index="anontransact">
              <AnonymousTransactions />
            </TabPanel>

            <TabPanel value={currentTab} index="settings">
              <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
                <DAOProfile />
                
                <Card>
                  <CardContent>
                    <Typography variant="h6">DAO Settings</Typography>
                    <Typography color="textSecondary" sx={{ mt: 1 }}>
                      Configure your DAO preferences and parameters.
                    </Typography>
                  </CardContent>
                </Card>
              </Box>
            </TabPanel>
          </Box>
        </Box>
      </Box>

      <Box sx={{ 
        borderTop: 1, 
        borderColor: 'divider',
        p: 2,
        mt: 'auto'
      }}>
        <Typography color="textSecondary" variant="body2">
          {chainId === 369 || chainId === 943 ? 
            'Running on PulseChain Network' : 'Connected to Ethereum Network'} • Block: #1234567
        </Typography>
      </Box>
    </Box>
    </AppWrapper>
  );
};

export default DAOPage;
=== ./ProposalCreation.tsx ===
// Main App: src/views/components/dashboard/ProposalCreation.tsx

import React, { useState, useEffect } from 'react';
import {
  Box,
  FormControl,
  TextField,
  Button,
  Alert,
  AlertTitle,
  Snackbar,
  FormControlLabel,
  Switch,
  CircularProgress
} from '@mui/material';
import { ethers } from 'ethers';
import { ContractService } from './contractService';
import { AuthorityService, VotingCapabilityType, AuthorityStateType, AuthorityStateResponse } from '../../../services/AuthorityService';

// Define the structure for proposal data with proper types
interface ProposalData {
  title: string;
  description: string;
  category: number;
  votingPeriod: number;
  isEmergency: boolean;
}

// Type definition for snackbar state
interface SnackbarState {
  open: boolean;
  message: string;
  severity: 'success' | 'info' | 'warning' | 'error';
}

// Type definition for web3 state
interface Web3State {
  account: string | null;
  isActive: boolean;
  chainId?: number;
}

const ProposalCreation: React.FC = () => {
  // Initialize state with proper typing
  const [contractService, setContractService] = useState<ContractService | null>(null);
  const [currentEpoch, setCurrentEpoch] = useState<number | null>(null);
  const [authorityState, setAuthorityState] = useState<AuthorityStateResponse | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  
useEffect(() => {
  if (!contractService) {
    console.error("[ProposalCreation] Contract service not initialized.");
  }

  if (!!contractService) {
    console.error("[ProposalCreation] Contract service initialized.");
  }
}, []);
  
  // Initialize web3 state with proper interface
  const [web3State, setWeb3State] = useState<Web3State>({
    account: null,
    isActive: false
  });

  // Initialize proposal data with proper interface
  const [proposalData, setProposalData] = useState<ProposalData>({
    title: '',
    description: '',
    category: 0,
    votingPeriod: 7,
    isEmergency: false
  });

  // Initialize snackbar state with proper interface
  const [snackbar, setSnackbar] = useState<SnackbarState>({
    open: false,
    message: '',
    severity: 'info'
  });

  useEffect(() => {
    initializeContract();
    loadAuthorityState();
  }, [web3State.account]);

  // Initialize contract with proper error handling and types
  const initializeContract = async (): Promise<void> => {
    try {
      if (!window.ethereum) {
        throw new Error('Web3 provider not found');
      }

      const provider = new ethers.providers.Web3Provider(window.ethereum as ethers.providers.ExternalProvider);
      const service = new ContractService(
        provider,
        '0x23767A0C9A072C6A081C27A1C03Cc95B9F9cc6E0' // Contract address
      );

      setContractService(service);
      
      const epoch = await service.getCurrentEpoch();
      setCurrentEpoch(epoch);

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
      console.error('Error initializing contract:', error);
      setSnackbar({
        open: true,
        message: `Failed to initialize contract: ${errorMessage}`,
        severity: 'error'
      });
    }
  };

  // Load authority state with proper typing and error handling
  const loadAuthorityState = async (): Promise<void> => {
    if (!contractService || !web3State.account) return;

    try {
      const authorityService = AuthorityService.getInstance(contractService);
      const state = await authorityService.getCurrentState(web3State.account);
      setAuthorityState(state);
    } catch (error) {
      console.error('Error loading authority state:', error);
    }
  };

  // Check if user can create proposals with proper capability checks
  const canCreateProposal = async (): Promise<boolean> => {
    if (!authorityState || !web3State.account || !contractService) return false;

    const authorityService = AuthorityService.getInstance(contractService);
    return await authorityService.hasCapability(
      web3State.account,
      VotingCapabilityType.CREATE_PROPOSAL
    );
  };

  // Handle form submission with proper type safety and error handling
  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>): Promise<void> => {
    e.preventDefault();
    if (!contractService || !await canCreateProposal()) return;

    setLoading(true);
    try {
      // Input validation
      if (!proposalData.title.trim()) {
        throw new Error('Title is required');
      }

      if (!proposalData.description.trim()) {
        throw new Error('Description is required');
      }

      if (proposalData.votingPeriod < 1 || proposalData.votingPeriod > 30) {
        throw new Error('Voting period must be between 1 and 30 days');
      }

      // Check for emergency powers if emergency proposal
      if (proposalData.isEmergency && web3State.account) {
        const authorityService = AuthorityService.getInstance(contractService);
        
        const hasEmergencyPower = await authorityService.hasCapability(
          web3State.account,
          VotingCapabilityType.EMERGENCY_VOTE
        );

        if (!hasEmergencyPower) {
          throw new Error('You do not have emergency proposal rights');
        }
      }

        // Create proposal using contract service
        const proposalId = await contractService.createProposal(
          proposalData.category,
          proposalData.votingPeriod,
          proposalData.title,
          proposalData.description
        );

      setSnackbar({
        open: true,
        message: `Proposal created successfully! ID: ${proposalId}`,
        severity: 'success'
      });

      // Reset form after successful submission
      setProposalData({
        title: '',
        description: '',
        category: 0,
        votingPeriod: 7,
        isEmergency: false
      });

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
      setSnackbar({
        open: true,
        message: 'Failed to create proposal: ' + errorMessage,
        severity: 'error'
      });
    } finally {
      setLoading(false);
    }
  };

  // Handle input changes with proper type safety
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    const { name, value, type, checked } = e.target;
    setProposalData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  // Early return if wallet not connected
  if (!web3State.isActive) {
    return (
      <Alert severity="warning">
        <AlertTitle>Connection Required</AlertTitle>
        Please connect your wallet to create proposals
      </Alert>
    );
  }

  // Early return if authority level insufficient
  if (!authorityState || authorityState.level < AuthorityStateType.FIRST_AUTHORITY) {
    return (
      <Alert severity="info">
        <AlertTitle>Authority Required</AlertTitle>
        You need to reach First Authority level ({AuthorityStateType.FIRST_AUTHORITY}) to create proposals.
        {authorityState && `Current level: ${authorityState.level.toFixed(8)}`}
      </Alert>
    );
  }

  return (
    <Box component="form" onSubmit={handleSubmit} sx={{ width: '100%', maxWidth: 600 }}>
      <FormControl fullWidth>
        <TextField
          name="title"
          label="Proposal Title"
          value={proposalData.title}
          onChange={handleInputChange}
          margin="normal"
          required
          fullWidth
        />
      </FormControl>

      <FormControl fullWidth>
        <TextField
          name="description"
          label="Proposal Description"
          value={proposalData.description}
          onChange={handleInputChange}
          margin="normal"
          required
          fullWidth
          multiline
          rows={4}
        />
      </FormControl>

      <FormControl fullWidth>
        <TextField
          name="category"
          label="Category"
          type="number"
          value={proposalData.category}
          onChange={handleInputChange}
          margin="normal"
          fullWidth
          InputProps={{ inputProps: { min: 0, max: 5 } }}
          helperText="0: General, 1: Technical, 2: Financial, 3: Governance, 4: Community, 5: Emergency"
        />
      </FormControl>

      <FormControl fullWidth>
        <TextField
          name="votingPeriod"
          label="Voting Period (days)"
          type="number"
          value={proposalData.votingPeriod}
          onChange={handleInputChange}
          margin="normal"
          fullWidth
          InputProps={{ inputProps: { min: 1, max: 30 } }}
          helperText="Duration of the voting period (1-30 days)"
        />
      </FormControl>

      <FormControlLabel
        control={
          <Switch
            name="isEmergency"
            checked={proposalData.isEmergency}
            onChange={handleInputChange}
            disabled={!authorityState?.capabilities.includes(VotingCapabilityType.EMERGENCY_VOTE)}
          />
        }
        label={
          authorityState?.capabilities.includes(VotingCapabilityType.EMERGENCY_VOTE)
            ? "Emergency Proposal"
            : "Emergency Proposal (Requires Higher Authority)"
        }
        sx={{ mt: 2 }}
      />

      <Button
        type="submit"
        variant="contained"
        color="primary"
        fullWidth
        disabled={loading}
        sx={{ mt: 3, mb: 2 }}
      >
        {loading ? <CircularProgress size={24} /> : 'Create Proposal'}
      </Button>

      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={() => setSnackbar(prev => ({ ...prev, open: false }))}
      >
        <Alert 
          onClose={() => setSnackbar(prev => ({ ...prev, open: false }))} 
          severity={snackbar.severity}
          variant="filled"
          sx={{ width: '100%' }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default ProposalCreation;
